{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar createResizeDetector = _interopDefault(require('element-resize-detector'));\n\nvar React = require('react');\n\nvar React__default = _interopDefault(React);\n\nvar PropTypes = _interopDefault(require('prop-types'));\n\nvar ReactDOM = _interopDefault(require('react-dom'));\n\nvar invariant = _interopDefault(require('invariant'));\n\nvar throttleDebounce = require('throttle-debounce');\n\nvar isShallowEqual = _interopDefault(require('shallowequal'));\n\nvar instances = {}; // Lazily require to not cause bug\n// https://github.com/ctrlplusb/react-sizeme/issues/6\n\nfunction resizeDetector() {\n  var strategy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'scroll';\n\n  if (!instances[strategy]) {\n    instances[strategy] = createResizeDetector({\n      strategy: strategy\n    });\n  }\n\n  return instances[strategy];\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n/* eslint-disable react/no-multi-comp */\n\n\nvar errMsg = 'react-sizeme: an error occurred whilst stopping to listen to node size changes';\nvar defaultConfig = {\n  monitorWidth: true,\n  monitorHeight: false,\n  monitorPosition: false,\n  refreshRate: 16,\n  refreshMode: 'throttle',\n  noPlaceholder: false,\n  resizeDetectorStrategy: 'scroll'\n};\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n/**\n * This is a utility wrapper component that will allow our higher order\n * component to get a ref handle on our wrapped components html.\n * @see https://gist.github.com/jimfb/32b587ee6177665fb4cf\n */\n\n\nvar ReferenceWrapper = function (_Component) {\n  inherits(ReferenceWrapper, _Component);\n\n  function ReferenceWrapper() {\n    classCallCheck(this, ReferenceWrapper);\n    return possibleConstructorReturn(this, (ReferenceWrapper.__proto__ || Object.getPrototypeOf(ReferenceWrapper)).apply(this, arguments));\n  }\n\n  createClass(ReferenceWrapper, [{\n    key: 'render',\n    value: function render() {\n      return React.Children.only(this.props.children);\n    }\n  }]);\n  return ReferenceWrapper;\n}(React.Component);\n\nReferenceWrapper.displayName = 'SizeMeReferenceWrapper';\nReferenceWrapper.propTypes = {\n  children: PropTypes.element.isRequired\n};\n\nfunction Placeholder(_ref) {\n  var className = _ref.className,\n      style = _ref.style; // Lets create the props for the temp element.\n\n  var phProps = {}; // We will use any provided className/style or else make the temp\n  // container take the full available space.\n\n  if (!className && !style) {\n    phProps.style = {\n      width: '100%',\n      height: '100%'\n    };\n  } else {\n    if (className) {\n      phProps.className = className;\n    }\n\n    if (style) {\n      phProps.style = style;\n    }\n  }\n\n  return React__default.createElement('div', phProps);\n}\n\nPlaceholder.displayName = 'SizeMePlaceholder';\nPlaceholder.propTypes = {\n  className: PropTypes.string,\n  style: PropTypes.object\n  /**\n   * As we need to maintain a ref on the root node that is rendered within our\n   * SizeMe component we need to wrap our entire render in a sub component.\n   * Without this, we lose the DOM ref after the placeholder is removed from\n   * the render and the actual component is rendered.\n   * It took me forever to figure this out, so tread extra careful on this one!\n   */\n\n};\n\nvar renderWrapper = function renderWrapper(WrappedComponent) {\n  function SizeMeRenderer(props) {\n    var explicitRef = props.explicitRef,\n        className = props.className,\n        style = props.style,\n        size = props.size,\n        disablePlaceholder = props.disablePlaceholder,\n        onSize = props.onSize,\n        restProps = objectWithoutProperties(props, ['explicitRef', 'className', 'style', 'size', 'disablePlaceholder', 'onSize']);\n    var noSizeData = size == null || size.width == null && size.height == null && size.position == null;\n    var renderPlaceholder = noSizeData && !disablePlaceholder;\n    var renderProps = {\n      className: className,\n      style: style\n    };\n\n    if (size != null) {\n      renderProps.size = size;\n    }\n\n    var toRender = renderPlaceholder ? React__default.createElement(Placeholder, {\n      className: className,\n      style: style\n    }) : React__default.createElement(WrappedComponent, _extends({}, renderProps, restProps));\n    return React__default.createElement(ReferenceWrapper, {\n      ref: explicitRef\n    }, toRender);\n  }\n\n  SizeMeRenderer.displayName = 'SizeMeRenderer(' + getDisplayName(WrappedComponent) + ')';\n  SizeMeRenderer.propTypes = {\n    explicitRef: PropTypes.func.isRequired,\n    className: PropTypes.string,\n    style: PropTypes.object,\n    // eslint-disable-line react/forbid-prop-types\n    size: PropTypes.shape({\n      width: PropTypes.number,\n      // eslint-disable-line react/no-unused-prop-types\n      height: PropTypes.number // eslint-disable-line react/no-unused-prop-types\n\n    }),\n    disablePlaceholder: PropTypes.bool,\n    onSize: PropTypes.func\n  };\n  return SizeMeRenderer;\n};\n/**\n * :: config -> Component -> WrappedComponent\n *\n * Higher order component that allows the wrapped component to become aware\n * of it's size, by receiving it as an object within it's props.\n *\n * @param  monitorWidth\n *   Default true, whether changes in the element's width should be monitored,\n *   causing a size property to be broadcast.\n * @param  monitorHeight\n *   Default false, whether changes in the element's height should be monitored,\n *   causing a size property to be broadcast.\n *\n * @return The wrapped component.\n */\n\n\nfunction withSize() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;\n  var _config$monitorWidth = config.monitorWidth,\n      monitorWidth = _config$monitorWidth === undefined ? defaultConfig.monitorWidth : _config$monitorWidth,\n      _config$monitorHeight = config.monitorHeight,\n      monitorHeight = _config$monitorHeight === undefined ? defaultConfig.monitorHeight : _config$monitorHeight,\n      _config$monitorPositi = config.monitorPosition,\n      monitorPosition = _config$monitorPositi === undefined ? defaultConfig.monitorPosition : _config$monitorPositi,\n      _config$refreshRate = config.refreshRate,\n      refreshRate = _config$refreshRate === undefined ? defaultConfig.refreshRate : _config$refreshRate,\n      _config$refreshMode = config.refreshMode,\n      refreshMode = _config$refreshMode === undefined ? defaultConfig.refreshMode : _config$refreshMode,\n      _config$noPlaceholder = config.noPlaceholder,\n      noPlaceholder = _config$noPlaceholder === undefined ? defaultConfig.noPlaceholder : _config$noPlaceholder,\n      _config$resizeDetecto = config.resizeDetectorStrategy,\n      resizeDetectorStrategy = _config$resizeDetecto === undefined ? defaultConfig.resizeDetectorStrategy : _config$resizeDetecto;\n  invariant(monitorWidth || monitorHeight || monitorPosition, 'You have to monitor at least one of the width, height, or position when using \"sizeMe\"');\n  invariant(refreshRate >= 16, \"It is highly recommended that you don't put your refreshRate lower than \" + '16 as this may cause layout thrashing.');\n  invariant(refreshMode === 'throttle' || refreshMode === 'debounce', 'The refreshMode should have a value of \"throttle\" or \"debounce\"');\n  var refreshDelayStrategy = refreshMode === 'throttle' ? throttleDebounce.throttle : throttleDebounce.debounce;\n  return function WrapComponent(WrappedComponent) {\n    var SizeMeRenderWrapper = renderWrapper(WrappedComponent);\n\n    var SizeAwareComponent = function (_React$Component) {\n      inherits(SizeAwareComponent, _React$Component);\n\n      function SizeAwareComponent() {\n        var _ref2;\n\n        var _temp, _this2, _ret;\n\n        classCallCheck(this, SizeAwareComponent);\n\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return _ret = (_temp = (_this2 = possibleConstructorReturn(this, (_ref2 = SizeAwareComponent.__proto__ || Object.getPrototypeOf(SizeAwareComponent)).call.apply(_ref2, [this].concat(args))), _this2), _this2.domEl = null, _this2.state = {\n          width: undefined,\n          height: undefined,\n          position: undefined\n        }, _this2.uninstall = function () {\n          if (_this2.domEl) {\n            try {\n              _this2.detector.uninstall(_this2.domEl);\n            } catch (err) {\n              // eslint-disable-next-line no-console\n              console.warn(errMsg);\n            }\n\n            _this2.domEl = null;\n          }\n        }, _this2.determineStrategy = function (props) {\n          if (props.onSize) {\n            if (!_this2.callbackState) {\n              _this2.callbackState = _extends({}, _this2.state);\n            }\n\n            _this2.strategy = 'callback';\n          } else {\n            _this2.strategy = 'render';\n          }\n        }, _this2.strategisedSetState = function (state) {\n          if (_this2.strategy === 'callback') {\n            _this2.callbackState = state;\n\n            _this2.props.onSize(state);\n          }\n\n          _this2.setState(state);\n        }, _this2.strategisedGetState = function () {\n          return _this2.strategy === 'callback' ? _this2.callbackState : _this2.state;\n        }, _this2.refCallback = function (element) {\n          _this2.element = element;\n        }, _this2.hasSizeChanged = function (current, next) {\n          var c = current;\n          var n = next;\n          var cp = c.position || {};\n          var np = n.position || {};\n          return monitorWidth && c.width !== n.width || monitorHeight && c.height !== n.height || monitorPosition && (cp.top !== np.top || cp.left !== np.left || cp.bottom !== np.bottom || cp.right !== np.right);\n        }, _this2.checkIfSizeChanged = refreshDelayStrategy(refreshRate, function (el) {\n          var _el$getBoundingClient = el.getBoundingClientRect(),\n              width = _el$getBoundingClient.width,\n              height = _el$getBoundingClient.height,\n              right = _el$getBoundingClient.right,\n              left = _el$getBoundingClient.left,\n              top = _el$getBoundingClient.top,\n              bottom = _el$getBoundingClient.bottom;\n\n          var next = {\n            width: monitorWidth ? width : null,\n            height: monitorHeight ? height : null,\n            position: monitorPosition ? {\n              right: right,\n              left: left,\n              top: top,\n              bottom: bottom\n            } : null\n          };\n\n          if (_this2.hasSizeChanged(_this2.strategisedGetState(), next)) {\n            _this2.strategisedSetState(next);\n          }\n        }), _temp), possibleConstructorReturn(_this2, _ret);\n      }\n\n      createClass(SizeAwareComponent, [{\n        key: 'componentDidMount',\n        value: function componentDidMount() {\n          this.detector = resizeDetector(resizeDetectorStrategy);\n          this.determineStrategy(this.props);\n          this.handleDOMNode();\n        }\n      }, {\n        key: 'componentDidUpdate',\n        value: function componentDidUpdate() {\n          this.determineStrategy(this.props);\n          this.handleDOMNode();\n        }\n      }, {\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n          // Change our size checker to a noop just in case we have some\n          // late running events.\n          this.hasSizeChanged = function () {\n            return undefined;\n          };\n\n          this.checkIfSizeChanged = function () {\n            return undefined;\n          };\n\n          this.uninstall();\n        }\n      }, {\n        key: 'handleDOMNode',\n        value: function handleDOMNode() {\n          var found = this.element && ReactDOM.findDOMNode(this.element);\n\n          if (!found) {\n            // If we previously had a dom node then we need to ensure that\n            // we remove any existing listeners to avoid memory leaks.\n            this.uninstall();\n            return;\n          }\n\n          if (!this.domEl) {\n            this.domEl = found;\n            this.detector.listenTo(this.domEl, this.checkIfSizeChanged);\n          } else if (!this.domEl.isSameNode(found)) {\n            this.uninstall();\n            this.domEl = found;\n            this.detector.listenTo(this.domEl, this.checkIfSizeChanged);\n          }\n        }\n      }, {\n        key: 'render',\n        value: function render() {\n          var disablePlaceholder = withSize.enableSSRBehaviour || withSize.noPlaceholders || noPlaceholder || this.strategy === 'callback';\n\n          var size = _extends({}, this.state);\n\n          return React__default.createElement(SizeMeRenderWrapper, _extends({\n            explicitRef: this.refCallback,\n            size: this.strategy === 'callback' ? null : size,\n            disablePlaceholder: disablePlaceholder\n          }, this.props));\n        }\n      }]);\n      return SizeAwareComponent;\n    }(React__default.Component);\n\n    SizeAwareComponent.displayName = 'SizeMe(' + getDisplayName(WrappedComponent) + ')';\n    SizeAwareComponent.propTypes = {\n      onSize: PropTypes.func\n    };\n    SizeAwareComponent.WrappedComponent = WrappedComponent;\n    return SizeAwareComponent;\n  };\n}\n/**\n * Allow SizeMe to run within SSR environments.  This is a \"global\" behaviour\n * flag that should be set within the initialisation phase of your application.\n *\n * Warning: don't set this flag unless you need to as using it may cause\n * extra render cycles to happen within your components depending on the logic\n * contained within them around the usage of the `size` data.\n *\n * DEPRECATED: Please use the global noPlaceholders\n */\n\n\nwithSize.enableSSRBehaviour = false;\n/**\n * Global configuration allowing to disable placeholder rendering for all\n * sizeMe components.\n */\n\nwithSize.noPlaceholders = false;\n\nvar SizeMe = function (_Component) {\n  inherits(SizeMe, _Component);\n\n  function SizeMe(props) {\n    classCallCheck(this, SizeMe);\n\n    var _this = possibleConstructorReturn(this, (SizeMe.__proto__ || Object.getPrototypeOf(SizeMe)).call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var children = props.children,\n        render = props.render,\n        sizeMeConfig = objectWithoutProperties(props, ['children', 'render']);\n\n    _this.createComponent(sizeMeConfig);\n\n    _this.state = {\n      size: {\n        width: undefined,\n        height: undefined\n      }\n    };\n    return _this;\n  }\n\n  createClass(SizeMe, [{\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      var _props = this.props,\n          prevChildren = _props.children,\n          prevRender = _props.render,\n          currentSizeMeConfig = objectWithoutProperties(_props, ['children', 'render']);\n      var nextChildren = prevProps.children,\n          nextRender = prevProps.render,\n          prevSizeMeConfig = objectWithoutProperties(prevProps, ['children', 'render']);\n\n      if (!isShallowEqual(currentSizeMeConfig, prevSizeMeConfig)) {\n        this.createComponent(currentSizeMeConfig);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var SizeAware = this.SizeAware;\n      var render = this.props.children || this.props.render;\n      return React__default.createElement(SizeAware, {\n        onSize: this.onSize\n      }, render({\n        size: this.state.size\n      }));\n    }\n  }]);\n  return SizeMe;\n}(React.Component);\n\nSizeMe.propTypes = {\n  children: PropTypes.func,\n  render: PropTypes.func\n};\nSizeMe.defaultProps = {\n  children: undefined,\n  render: undefined\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.createComponent = function (config) {\n    _this2.SizeAware = withSize(config)(function (_ref) {\n      var children = _ref.children;\n      return children;\n    });\n  };\n\n  this.onSize = function (size) {\n    return _this2.setState({\n      size: size\n    });\n  };\n};\n\nwithSize.SizeMe = SizeMe;\nwithSize.withSize = withSize;\nmodule.exports = withSize;","map":{"version":3,"sources":["../src/resize-detector.js","../src/with-size.js","../src/component.js","../src/index.js"],"names":["instances","strategy","errMsg","defaultConfig","WrappedComponent","ReferenceWrapper","Component","displayName","Children","children","PropTypes","className","style","phProps","width","height","React","Placeholder","object","renderWrapper","explicitRef","size","disablePlaceholder","onSize","restProps","props","noSizeData","renderPlaceholder","renderProps","toRender","getDisplayName","func","config","monitorWidth","monitorHeight","monitorPosition","refreshRate","refreshMode","noPlaceholder","resizeDetectorStrategy","refreshDelayStrategy","throttle","debounce","SizeMeRenderWrapper","SizeAwareComponent","undefined","resizeDetector","found","ReactDOM","c","n","cp","np","right","left","top","bottom","el","next","withSize","SizeMe","propTypes","defaultProps","render","sizeMeConfig","prevProps","prevChildren","prevRender","currentSizeMeConfig","nextChildren","nextRender","prevSizeMeConfig","isShallowEqual","createComponent","SizeAware"],"mappings":"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","sourcesContent":["import createResizeDetector from 'element-resize-detector'\n\nconst instances = {}\n\n// Lazily require to not cause bug\n// https://github.com/ctrlplusb/react-sizeme/issues/6\nfunction resizeDetector(strategy = 'scroll') {\n  if (!instances[strategy]) {\n    instances[strategy] = createResizeDetector({\n      strategy,\n    })\n  }\n\n  return instances[strategy]\n}\n\nexport default resizeDetector\n","/* eslint-disable react/no-multi-comp */\n/* eslint-disable react/require-default-props */\n/* eslint-disable react/no-find-dom-node */\n\nimport React, { Children, Component } from 'react'\nimport PropTypes from 'prop-types'\nimport ReactDOM from 'react-dom'\nimport invariant from 'invariant'\nimport { debounce, throttle } from 'throttle-debounce'\nimport resizeDetector from './resize-detector'\n\nconst errMsg =\n  'react-sizeme: an error occurred whilst stopping to listen to node size changes'\n\nconst defaultConfig = {\n  monitorWidth: true,\n  monitorHeight: false,\n  monitorPosition: false,\n  refreshRate: 16,\n  refreshMode: 'throttle',\n  noPlaceholder: false,\n  resizeDetectorStrategy: 'scroll',\n}\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component'\n}\n\n/**\n * This is a utility wrapper component that will allow our higher order\n * component to get a ref handle on our wrapped components html.\n * @see https://gist.github.com/jimfb/32b587ee6177665fb4cf\n */\nclass ReferenceWrapper extends Component {\n  static displayName = 'SizeMeReferenceWrapper'\n\n  render() {\n    return Children.only(this.props.children)\n  }\n}\nReferenceWrapper.propTypes = { children: PropTypes.element.isRequired }\n\nfunction Placeholder({ className, style }) {\n  // Lets create the props for the temp element.\n  const phProps = {}\n\n  // We will use any provided className/style or else make the temp\n  // container take the full available space.\n  if (!className && !style) {\n    phProps.style = { width: '100%', height: '100%' }\n  } else {\n    if (className) {\n      phProps.className = className\n    }\n    if (style) {\n      phProps.style = style\n    }\n  }\n\n  return <div {...phProps} />\n}\nPlaceholder.displayName = 'SizeMePlaceholder'\nPlaceholder.propTypes = {\n  className: PropTypes.string,\n  style: PropTypes.object,\n}\n\n/**\n * As we need to maintain a ref on the root node that is rendered within our\n * SizeMe component we need to wrap our entire render in a sub component.\n * Without this, we lose the DOM ref after the placeholder is removed from\n * the render and the actual component is rendered.\n * It took me forever to figure this out, so tread extra careful on this one!\n */\nconst renderWrapper = WrappedComponent => {\n  function SizeMeRenderer(props) {\n    const {\n      explicitRef,\n      className,\n      style,\n      size,\n      disablePlaceholder,\n      onSize,\n      ...restProps\n    } = props\n\n    const noSizeData =\n      size == null ||\n      (size.width == null && size.height == null && size.position == null)\n\n    const renderPlaceholder = noSizeData && !disablePlaceholder\n\n    const renderProps = {\n      className,\n      style,\n    }\n\n    if (size != null) {\n      renderProps.size = size\n    }\n\n    const toRender = renderPlaceholder ? (\n      <Placeholder className={className} style={style} />\n    ) : (\n      <WrappedComponent {...renderProps} {...restProps} />\n    )\n\n    return <ReferenceWrapper ref={explicitRef}>{toRender}</ReferenceWrapper>\n  }\n\n  SizeMeRenderer.displayName = `SizeMeRenderer(${getDisplayName(\n    WrappedComponent,\n  )})`\n\n  SizeMeRenderer.propTypes = {\n    explicitRef: PropTypes.func.isRequired,\n    className: PropTypes.string,\n    style: PropTypes.object, // eslint-disable-line react/forbid-prop-types\n    size: PropTypes.shape({\n      width: PropTypes.number, // eslint-disable-line react/no-unused-prop-types\n      height: PropTypes.number, // eslint-disable-line react/no-unused-prop-types\n    }),\n    disablePlaceholder: PropTypes.bool,\n    onSize: PropTypes.func,\n  }\n\n  return SizeMeRenderer\n}\n\n/**\n * :: config -> Component -> WrappedComponent\n *\n * Higher order component that allows the wrapped component to become aware\n * of it's size, by receiving it as an object within it's props.\n *\n * @param  monitorWidth\n *   Default true, whether changes in the element's width should be monitored,\n *   causing a size property to be broadcast.\n * @param  monitorHeight\n *   Default false, whether changes in the element's height should be monitored,\n *   causing a size property to be broadcast.\n *\n * @return The wrapped component.\n */\nfunction withSize(config = defaultConfig) {\n  const {\n    monitorWidth = defaultConfig.monitorWidth,\n    monitorHeight = defaultConfig.monitorHeight,\n    monitorPosition = defaultConfig.monitorPosition,\n    refreshRate = defaultConfig.refreshRate,\n    refreshMode = defaultConfig.refreshMode,\n    noPlaceholder = defaultConfig.noPlaceholder,\n    resizeDetectorStrategy = defaultConfig.resizeDetectorStrategy,\n  } = config\n\n  invariant(\n    monitorWidth || monitorHeight || monitorPosition,\n    'You have to monitor at least one of the width, height, or position when using \"sizeMe\"',\n  )\n\n  invariant(\n    refreshRate >= 16,\n    \"It is highly recommended that you don't put your refreshRate lower than \" +\n      '16 as this may cause layout thrashing.',\n  )\n\n  invariant(\n    refreshMode === 'throttle' || refreshMode === 'debounce',\n    'The refreshMode should have a value of \"throttle\" or \"debounce\"',\n  )\n\n  const refreshDelayStrategy = refreshMode === 'throttle' ? throttle : debounce\n\n  return function WrapComponent(WrappedComponent) {\n    const SizeMeRenderWrapper = renderWrapper(WrappedComponent)\n\n    class SizeAwareComponent extends React.Component {\n      static displayName = `SizeMe(${getDisplayName(WrappedComponent)})`\n\n      static propTypes = {\n        onSize: PropTypes.func,\n      }\n\n      domEl = null\n\n      state = {\n        width: undefined,\n        height: undefined,\n        position: undefined,\n      }\n\n      componentDidMount() {\n        this.detector = resizeDetector(resizeDetectorStrategy)\n        this.determineStrategy(this.props)\n        this.handleDOMNode()\n      }\n\n      componentDidUpdate() {\n        this.determineStrategy(this.props)\n        this.handleDOMNode()\n      }\n\n      componentWillUnmount() {\n        // Change our size checker to a noop just in case we have some\n        // late running events.\n        this.hasSizeChanged = () => undefined\n        this.checkIfSizeChanged = () => undefined\n        this.uninstall()\n      }\n\n      uninstall = () => {\n        if (this.domEl) {\n          try {\n            this.detector.uninstall(this.domEl)\n          } catch (err) {\n            // eslint-disable-next-line no-console\n            console.warn(errMsg)\n          }\n          this.domEl = null\n        }\n      }\n\n      determineStrategy = props => {\n        if (props.onSize) {\n          if (!this.callbackState) {\n            this.callbackState = {\n              ...this.state,\n            }\n          }\n          this.strategy = 'callback'\n        } else {\n          this.strategy = 'render'\n        }\n      }\n\n      strategisedSetState = state => {\n        if (this.strategy === 'callback') {\n          this.callbackState = state\n          this.props.onSize(state)\n        }\n        this.setState(state)\n      }\n\n      strategisedGetState = () =>\n        this.strategy === 'callback' ? this.callbackState : this.state\n\n      handleDOMNode() {\n        const found = this.element && ReactDOM.findDOMNode(this.element)\n\n        if (!found) {\n          // If we previously had a dom node then we need to ensure that\n          // we remove any existing listeners to avoid memory leaks.\n          this.uninstall()\n          return\n        }\n\n        if (!this.domEl) {\n          this.domEl = found\n          this.detector.listenTo(this.domEl, this.checkIfSizeChanged)\n        } else if (!this.domEl.isSameNode(found)) {\n          this.uninstall()\n          this.domEl = found\n          this.detector.listenTo(this.domEl, this.checkIfSizeChanged)\n        } else {\n          // Do nothing 👍\n        }\n      }\n\n      refCallback = element => {\n        this.element = element\n      }\n\n      hasSizeChanged = (current, next) => {\n        const c = current\n        const n = next\n        const cp = c.position || {}\n        const np = n.position || {}\n\n        return (\n          (monitorWidth && c.width !== n.width) ||\n          (monitorHeight && c.height !== n.height) ||\n          (monitorPosition &&\n            (cp.top !== np.top ||\n              cp.left !== np.left ||\n              cp.bottom !== np.bottom ||\n              cp.right !== np.right))\n        )\n      }\n\n      checkIfSizeChanged = refreshDelayStrategy(refreshRate, el => {\n        const {\n          width,\n          height,\n          right,\n          left,\n          top,\n          bottom,\n        } = el.getBoundingClientRect()\n\n        const next = {\n          width: monitorWidth ? width : null,\n          height: monitorHeight ? height : null,\n          position: monitorPosition ? { right, left, top, bottom } : null,\n        }\n\n        if (this.hasSizeChanged(this.strategisedGetState(), next)) {\n          this.strategisedSetState(next)\n        }\n      })\n\n      render() {\n        const disablePlaceholder =\n          withSize.enableSSRBehaviour ||\n          withSize.noPlaceholders ||\n          noPlaceholder ||\n          this.strategy === 'callback'\n\n        const size = { ...this.state }\n\n        return (\n          <SizeMeRenderWrapper\n            explicitRef={this.refCallback}\n            size={this.strategy === 'callback' ? null : size}\n            disablePlaceholder={disablePlaceholder}\n            {...this.props}\n          />\n        )\n      }\n    }\n\n    SizeAwareComponent.WrappedComponent = WrappedComponent\n\n    return SizeAwareComponent\n  }\n}\n\n/**\n * Allow SizeMe to run within SSR environments.  This is a \"global\" behaviour\n * flag that should be set within the initialisation phase of your application.\n *\n * Warning: don't set this flag unless you need to as using it may cause\n * extra render cycles to happen within your components depending on the logic\n * contained within them around the usage of the `size` data.\n *\n * DEPRECATED: Please use the global noPlaceholders\n */\nwithSize.enableSSRBehaviour = false\n\n/**\n * Global configuration allowing to disable placeholder rendering for all\n * sizeMe components.\n */\nwithSize.noPlaceholders = false\n\nexport default withSize\n","import React, { Component } from 'react'\nimport isShallowEqual from 'shallowequal'\nimport PropTypes from 'prop-types'\nimport withSize from './with-size'\n\nexport default class SizeMe extends Component {\n  static propTypes = {\n    children: PropTypes.func,\n    render: PropTypes.func,\n  }\n\n  static defaultProps = {\n    children: undefined,\n    render: undefined,\n  }\n\n  constructor(props) {\n    super(props)\n    const { children, render, ...sizeMeConfig } = props\n    this.createComponent(sizeMeConfig)\n    this.state = {\n      size: {\n        width: undefined,\n        height: undefined,\n      },\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      children: prevChildren,\n      render: prevRender,\n      ...currentSizeMeConfig\n    } = this.props\n    const {\n      children: nextChildren,\n      render: nextRender,\n      ...prevSizeMeConfig\n    } = prevProps\n    if (!isShallowEqual(currentSizeMeConfig, prevSizeMeConfig)) {\n      this.createComponent(currentSizeMeConfig)\n    }\n  }\n\n  createComponent = config => {\n    this.SizeAware = withSize(config)(({ children }) => children)\n  }\n\n  onSize = size => this.setState({ size })\n\n  render() {\n    const { SizeAware } = this\n    const render = this.props.children || this.props.render\n    return (\n      <SizeAware onSize={this.onSize}>\n        {render({ size: this.state.size })}\n      </SizeAware>\n    )\n  }\n}\n","import withSize from './with-size'\nimport SizeMe from './component'\n\nwithSize.SizeMe = SizeMe\nwithSize.withSize = withSize\n\nexport default withSize\n"]},"metadata":{},"sourceType":"module"}