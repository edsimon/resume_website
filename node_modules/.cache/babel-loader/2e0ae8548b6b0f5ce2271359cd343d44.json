{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar _extends = _interopDefault(require('@babel/runtime/helpers/esm/extends'));\n\nvar _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/esm/objectWithoutPropertiesLoose'));\n\nvar React = require('react');\n\nvar React__default = _interopDefault(React);\n\nlet bugfixes = undefined;\nlet applyAnimatedValues = undefined;\nlet colorNames = [];\n\nlet requestFrame = cb => typeof window !== 'undefined' && window.requestAnimationFrame(cb);\n\nlet cancelFrame = cb => typeof window !== 'undefined' && window.cancelAnimationFrame(cb);\n\nlet interpolation = undefined;\n\nlet now = () => Date.now();\n\nlet defaultElement = undefined;\nlet createAnimatedStyle = undefined;\n\nconst injectApplyAnimatedValues = (fn, transform) => applyAnimatedValues = {\n  fn,\n  transform\n};\n\nconst injectColorNames = names => colorNames = names;\n\nconst injectBugfixes = fn => bugfixes = fn;\n\nconst injectInterpolation = cls => interpolation = cls;\n\nconst injectFrame = (raf, caf) => {\n  var _ref = [raf, caf];\n  requestFrame = _ref[0];\n  cancelFrame = _ref[1];\n  return _ref;\n};\n\nconst injectNow = nowFn => now = nowFn;\n\nconst injectDefaultElement = el => defaultElement = el;\n\nconst injectCreateAnimatedStyle = factory => createAnimatedStyle = factory;\n\nvar Globals =\n/*#__PURE__*/\nObject.freeze({\n  get bugfixes() {\n    return bugfixes;\n  },\n\n  get applyAnimatedValues() {\n    return applyAnimatedValues;\n  },\n\n  get colorNames() {\n    return colorNames;\n  },\n\n  get requestFrame() {\n    return requestFrame;\n  },\n\n  get cancelFrame() {\n    return cancelFrame;\n  },\n\n  get interpolation() {\n    return interpolation;\n  },\n\n  get now() {\n    return now;\n  },\n\n  get defaultElement() {\n    return defaultElement;\n  },\n\n  get createAnimatedStyle() {\n    return createAnimatedStyle;\n  },\n\n  injectApplyAnimatedValues: injectApplyAnimatedValues,\n  injectColorNames: injectColorNames,\n  injectBugfixes: injectBugfixes,\n  injectInterpolation: injectInterpolation,\n  injectFrame: injectFrame,\n  injectNow: injectNow,\n  injectDefaultElement: injectDefaultElement,\n  injectCreateAnimatedStyle: injectCreateAnimatedStyle\n});\n\nclass Animated {\n  attach() {}\n\n  detach() {}\n\n  getValue() {}\n\n  getAnimatedValue() {\n    return this.getValue();\n  }\n\n  addChild(child) {}\n\n  removeChild(child) {}\n\n  getChildren() {\n    return [];\n  }\n\n}\n\nconst getValues = object => Object.keys(object).map(k => object[k]);\n\nclass AnimatedWithChildren extends Animated {\n  constructor() {\n    var _this;\n\n    super(...arguments);\n    _this = this;\n    this.children = [];\n\n    this.getChildren = () => this.children;\n\n    this.getPayload = function (index) {\n      if (index === void 0) {\n        index = undefined;\n      }\n\n      return index !== void 0 && _this.payload ? _this.payload[index] : _this.payload || _this;\n    };\n  }\n\n  addChild(child) {\n    if (this.children.length === 0) this.attach();\n    this.children.push(child);\n  }\n\n  removeChild(child) {\n    const index = this.children.indexOf(child);\n    this.children.splice(index, 1);\n    if (this.children.length === 0) this.detach();\n  }\n\n}\n\nclass AnimatedArrayWithChildren extends AnimatedWithChildren {\n  constructor() {\n    super(...arguments);\n    this.payload = [];\n\n    this.getAnimatedValue = () => this.getValue();\n\n    this.attach = () => this.payload.forEach(p => p instanceof Animated && p.addChild(this));\n\n    this.detach = () => this.payload.forEach(p => p instanceof Animated && p.removeChild(this));\n  }\n\n}\n\nclass AnimatedObjectWithChildren extends AnimatedWithChildren {\n  constructor() {\n    super(...arguments);\n    this.payload = {};\n\n    this.getAnimatedValue = () => this.getValue(true);\n\n    this.attach = () => getValues(this.payload).forEach(s => s instanceof Animated && s.addChild(this));\n\n    this.detach = () => getValues(this.payload).forEach(s => s instanceof Animated && s.removeChild(this));\n  }\n\n  getValue(animated) {\n    if (animated === void 0) {\n      animated = false;\n    }\n\n    const payload = {};\n\n    for (const key in this.payload) {\n      const value = this.payload[key];\n      if (animated && !(value instanceof Animated)) continue;\n      payload[key] = value instanceof Animated ? value[animated ? 'getAnimatedValue' : 'getValue']() : value;\n    }\n\n    return payload;\n  }\n\n}\n\nclass Interpolation {\n  // Default config = config, args\n  // Short config   = range, output, extrapolate\n  static create(config, output, extra) {\n    if (typeof config === 'function') return config;else if (interpolation && config.output && typeof config.output[0] === 'string') return interpolation(config);else if (Array.isArray(config)) return Interpolation.create({\n      range: config,\n      output,\n      extrapolate: extra || 'extend'\n    });\n    let outputRange = config.output;\n    let inputRange = config.range || [0, 1];\n\n    let easing = config.easing || (t => t);\n\n    let extrapolateLeft = 'extend';\n    let map = config.map;\n    if (config.extrapolateLeft !== undefined) extrapolateLeft = config.extrapolateLeft;else if (config.extrapolate !== undefined) extrapolateLeft = config.extrapolate;\n    let extrapolateRight = 'extend';\n    if (config.extrapolateRight !== undefined) extrapolateRight = config.extrapolateRight;else if (config.extrapolate !== undefined) extrapolateRight = config.extrapolate;\n    return input => {\n      let range = findRange(input, inputRange);\n      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight, map);\n    };\n  }\n\n}\n\nfunction interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {\n  let result = map ? map(input) : input; // Extrapolate\n\n  if (result < inputMin) {\n    if (extrapolateLeft === 'identity') return result;else if (extrapolateLeft === 'clamp') result = inputMin;\n  }\n\n  if (result > inputMax) {\n    if (extrapolateRight === 'identity') return result;else if (extrapolateRight === 'clamp') result = inputMax;\n  }\n\n  if (outputMin === outputMax) return outputMin;\n  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax; // Input Range\n\n  if (inputMin === -Infinity) result = -result;else if (inputMax === Infinity) result = result - inputMin;else result = (result - inputMin) / (inputMax - inputMin); // Easing\n\n  result = easing(result); // Output Range\n\n  if (outputMin === -Infinity) result = -result;else if (outputMax === Infinity) result = result + outputMin;else result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\n\nfunction findRange(input, inputRange) {\n  for (var i = 1; i < inputRange.length - 1; ++i) if (inputRange[i] >= input) break;\n\n  return i - 1;\n}\n\nclass AnimatedInterpolation extends AnimatedArrayWithChildren {\n  constructor(parents, _config, _arg) {\n    super();\n\n    this.getValue = () => this.calc(...this.payload.map(value => value.getValue()));\n\n    this.updateConfig = (config, arg) => this.calc = Interpolation.create(config, arg);\n\n    this.interpolate = (config, arg) => new AnimatedInterpolation(this, config, arg);\n\n    this.payload = // AnimatedArrays should unfold, except AnimatedInterpolation which is taken as is\n    parents instanceof AnimatedArrayWithChildren && !parents.updateConfig ? parents.payload : Array.isArray(parents) ? parents : [parents];\n    this.calc = Interpolation.create(_config, _arg);\n  }\n\n}\n\nconst interpolate$1 = (parents, config, arg) => parents && new AnimatedInterpolation(parents, config, arg);\n/**\n * Animated works by building a directed acyclic graph of dependencies\n * transparently when you render your Animated components.\n *\n *               new Animated.Value(0)\n *     .interpolate()        .interpolate()    new Animated.Value(1)\n *         opacity               translateY      scale\n *          style                         transform\n *         View#234                         style\n *                                         View#123\n *\n * A) Top Down phase\n * When an Animated.Value is updated, we recursively go down through this\n * graph in order to find leaf nodes: the views that we flag as needing\n * an update.\n *\n * B) Bottom Up phase\n * When a view is flagged as needing an update, we recursively go back up\n * in order to build the new value that it needs. The reason why we need\n * this two-phases process is to deal with composite props such as\n * transform which can receive values from multiple parents.\n */\n\n\nfunction findAnimatedStyles(node, styles) {\n  if (typeof node.update === 'function') styles.add(node);else node.getChildren().forEach(child => findAnimatedStyles(child, styles));\n}\n/**\n * Standard value for driving animations.  One `Animated.Value` can drive\n * multiple properties in a synchronized fashion, but can only be driven by one\n * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,\n * or calling `setValue`) will stop any previous ones.\n */\n\n\nclass AnimatedValue extends AnimatedWithChildren {\n  constructor(_value) {\n    var _this;\n\n    super();\n    _this = this;\n\n    this.setValue = function (value, flush) {\n      if (flush === void 0) {\n        flush = true;\n      }\n\n      _this.value = value;\n      if (flush) _this.flush();\n    };\n\n    this.getValue = () => this.value;\n\n    this.updateStyles = () => findAnimatedStyles(this, this.animatedStyles);\n\n    this.updateValue = value => this.flush(this.value = value);\n\n    this.interpolate = (config, arg) => new AnimatedInterpolation(this, config, arg);\n\n    this.value = _value;\n    this.animatedStyles = new Set();\n    this.done = false;\n    this.startPosition = _value;\n    this.lastPosition = _value;\n    this.lastVelocity = undefined;\n    this.lastTime = undefined;\n    this.controller = undefined;\n  }\n\n  flush() {\n    if (this.animatedStyles.size === 0) this.updateStyles();\n    this.animatedStyles.forEach(animatedStyle => animatedStyle.update());\n  }\n\n  prepare(controller) {\n    // Values stay loyal to their original controller, this is also a way to\n    // detect trailing values originating from a foreign controller\n    if (this.controller === undefined) this.controller = controller;\n\n    if (this.controller === controller) {\n      this.startPosition = this.value;\n      this.lastPosition = this.value;\n      this.lastVelocity = controller.isActive ? this.lastVelocity : undefined;\n      this.lastTime = controller.isActive ? this.lastTime : undefined;\n      this.done = false;\n      this.animatedStyles.clear();\n    }\n  }\n\n}\n\nclass AnimatedArray extends AnimatedArrayWithChildren {\n  constructor(array) {\n    var _this;\n\n    super();\n    _this = this;\n\n    this.setValue = function (value, flush) {\n      if (flush === void 0) {\n        flush = true;\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === _this.payload.length) value.forEach((v, i) => _this.payload[i].setValue(v, flush));\n      } else _this.payload.forEach((v, i) => _this.payload[i].setValue(value, flush));\n    };\n\n    this.getValue = () => this.payload.map(v => v.getValue());\n\n    this.interpolate = (config, arg) => new AnimatedInterpolation(this, config, arg);\n\n    this.payload = array.map(n => new AnimatedValue(n));\n  }\n\n}\n\nlet active = false;\nconst controllers = new Set();\n\nconst frameLoop = () => {\n  let time = now();\n\n  for (let controller of controllers) {\n    let isDone = true;\n    let noChange = true;\n\n    for (let configIdx = 0; configIdx < controller.configs.length; configIdx++) {\n      let config = controller.configs[configIdx];\n      let endOfAnimation, lastTime;\n\n      for (let valIdx = 0; valIdx < config.animatedValues.length; valIdx++) {\n        let animation = config.animatedValues[valIdx]; // If an animation is done, skip, until all of them conclude\n\n        if (animation.done) continue;\n        let from = config.fromValues[valIdx];\n        let to = config.toValues[valIdx];\n        let position = animation.lastPosition;\n        let isAnimated = to instanceof Animated;\n        let velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[valIdx] : config.initialVelocity;\n        if (isAnimated) to = to.getValue(); // Conclude animation if it's either immediate, or from-values match end-state\n\n        if (config.immediate || !isAnimated && !config.decay && from === to) {\n          animation.updateValue(to);\n          animation.done = true;\n          continue;\n        } // Doing delay here instead of setTimeout is one async worry less\n\n\n        if (config.delay && time - controller.startTime < config.delay) {\n          isDone = false;\n          continue;\n        } // Flag change\n\n\n        noChange = false; // Break animation when string values are involved\n\n        if (typeof from === 'string' || typeof to === 'string') {\n          animation.updateValue(to);\n          animation.done = true;\n          continue;\n        }\n\n        if (config.duration !== void 0) {\n          /** Duration easing */\n          position = from + config.easing((time - controller.startTime - config.delay) / config.duration) * (to - from);\n          endOfAnimation = time >= controller.startTime + config.delay + config.duration;\n        } else if (config.decay) {\n          /** Decay easing */\n          position = from + velocity / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (time - controller.startTime)));\n          endOfAnimation = Math.abs(animation.lastPosition - position) < 0.1;\n          if (endOfAnimation) to = position;\n        } else {\n          /** Spring easing */\n          lastTime = animation.lastTime !== void 0 ? animation.lastTime : time;\n          velocity = animation.lastVelocity !== void 0 ? animation.lastVelocity : config.initialVelocity; // If we lost a lot of frames just jump to the end.\n\n          if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/\n\n          let numSteps = Math.floor(time - lastTime);\n\n          for (let i = 0; i < numSteps; ++i) {\n            let force = -config.tension * (position - to);\n            let damping = -config.friction * velocity;\n            let acceleration = (force + damping) / config.mass;\n            velocity = velocity + acceleration * 1 / 1000;\n            position = position + velocity * 1 / 1000;\n          } // Conditions for stopping the spring animation\n\n\n          let isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;\n          let isVelocity = Math.abs(velocity) <= config.precision;\n          let isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;\n          endOfAnimation = isOvershooting || isVelocity && isDisplacement;\n          animation.lastVelocity = velocity;\n          animation.lastTime = time;\n        } // Trails aren't done until their parents conclude\n\n\n        if (isAnimated && !config.toValues[valIdx].done) endOfAnimation = false;\n\n        if (endOfAnimation) {\n          // Ensure that we end up with a round value\n          if (animation.value !== to) position = to;\n          animation.done = true;\n        } else isDone = false;\n\n        animation.updateValue(position);\n        animation.lastPosition = position;\n      } // Keep track of updated values only when necessary\n\n\n      if (controller.props.onFrame || !controller.props.native) controller.animatedProps[config.name] = config.interpolation.getValue();\n    } // Update callbacks in the end of the frame\n\n\n    if (controller.props.onFrame || !controller.props.native) {\n      if (!controller.props.native && controller.onUpdate) controller.onUpdate();\n      if (controller.props.onFrame) controller.props.onFrame(controller.animatedProps);\n    } // Either call onEnd or next frame\n\n\n    if (isDone) {\n      controllers.delete(controller);\n      controller.debouncedOnEnd({\n        finished: true,\n        noChange\n      });\n    }\n  } // Loop over as long as there are controllers ...\n\n\n  if (controllers.size) requestFrame(frameLoop);else active = false;\n};\n\nconst addController = controller => {\n  if (!controllers.has(controller)) {\n    controllers.add(controller);\n    if (!active) requestFrame(frameLoop);\n    active = true;\n  }\n};\n\nconst removeController = controller => {\n  if (controllers.has(controller)) {\n    controllers.delete(controller);\n  }\n};\n\nfunction withDefault(value, defaultValue) {\n  return value === undefined || value === null ? defaultValue : value;\n}\n\nfunction toArray(a) {\n  return a !== void 0 ? Array.isArray(a) ? a : [a] : [];\n}\n\nfunction shallowEqual(a, b) {\n  if (typeof a !== typeof b) return false;\n  if (typeof a === 'string' || typeof a === 'number') return a === b;\n  let i;\n\n  for (i in a) if (!(i in b)) return false;\n\n  for (i in b) if (a[i] !== b[i]) return false;\n\n  return i === void 0 ? a === b : true;\n}\n\nfunction callProp(obj) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return typeof obj === 'function' ? obj(...args) : obj;\n}\n\nfunction getValues$1(object) {\n  return Object.keys(object).map(k => object[k]);\n}\n\nfunction getForwardProps(props) {\n  const to = props.to,\n        from = props.from,\n        config = props.config,\n        native = props.native,\n        onStart = props.onStart,\n        onRest = props.onRest,\n        onFrame = props.onFrame,\n        children = props.children,\n        reset = props.reset,\n        reverse = props.reverse,\n        force = props.force,\n        immediate = props.immediate,\n        impl = props.impl,\n        inject = props.inject,\n        delay = props.delay,\n        attach = props.attach,\n        destroyed = props.destroyed,\n        interpolateTo = props.interpolateTo,\n        autoStart = props.autoStart,\n        ref = props.ref,\n        forward = _objectWithoutPropertiesLoose(props, [\"to\", \"from\", \"config\", \"native\", \"onStart\", \"onRest\", \"onFrame\", \"children\", \"reset\", \"reverse\", \"force\", \"immediate\", \"impl\", \"inject\", \"delay\", \"attach\", \"destroyed\", \"interpolateTo\", \"autoStart\", \"ref\"]);\n\n  return forward;\n}\n\nfunction interpolateTo(props) {\n  const forward = getForwardProps(props);\n  const rest = Object.keys(props).reduce((a, k) => forward[k] !== void 0 ? a : _extends({}, a, {\n    [k]: props[k]\n  }), {});\n  return _extends({\n    to: forward\n  }, rest);\n}\n\nfunction convertToAnimatedValue(acc, _ref) {\n  let name = _ref[0],\n      value = _ref[1];\n  return _extends({}, acc, {\n    [name]: new (Array.isArray(value) ? AnimatedArray : AnimatedValue)(value)\n  });\n}\n\nfunction convertValues(props) {\n  const from = props.from,\n        to = props.to,\n        native = props.native;\n  const allProps = Object.entries(_extends({}, from, to));\n  return native ? allProps.reduce(convertToAnimatedValue, {}) : _extends({}, from, to);\n}\n\nfunction handleRef(ref, forward) {\n  if (forward) {\n    // If it's a function, assume it's a ref callback\n    if (typeof forward === 'function') forward(ref);else if (typeof forward === 'object') {\n      // If it's an object and has a 'current' property, assume it's a ref object\n      forward.current = ref;\n    }\n  }\n\n  return ref;\n}\n\nclass Controller {\n  constructor(props, config) {\n    if (config === void 0) {\n      config = {\n        native: true,\n        interpolateTo: true,\n        autoStart: true\n      };\n    }\n\n    this.getValues = () => this.props.native ? this.interpolations : this.animatedProps;\n\n    this.dependents = new Set();\n    this.isActive = false;\n    this.hasChanged = false;\n    this.props = {};\n    this.merged = {};\n    this.animations = {};\n    this.interpolations = {};\n    this.animatedProps = {};\n    this.configs = [];\n    this.frame = undefined;\n    this.startTime = undefined;\n    this.lastTime = undefined;\n    this.update(_extends({}, props, config));\n  }\n\n  update(props) {\n    this.props = _extends({}, this.props, props);\n\n    let _ref = this.props.interpolateTo ? interpolateTo(this.props) : this.props,\n        _ref$from = _ref.from,\n        from = _ref$from === void 0 ? {} : _ref$from,\n        _ref$to = _ref.to,\n        to = _ref$to === void 0 ? {} : _ref$to,\n        _ref$config = _ref.config,\n        config = _ref$config === void 0 ? {} : _ref$config,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay,\n        reverse = _ref.reverse,\n        attach = _ref.attach,\n        reset = _ref.reset,\n        immediate = _ref.immediate,\n        autoStart = _ref.autoStart,\n        ref = _ref.ref; // Reverse values when requested\n\n\n    if (reverse) {\n      var _ref2 = [to, from];\n      from = _ref2[0];\n      to = _ref2[1];\n    }\n\n    this.hasChanged = false; // Attachment handling, trailed springs can \"attach\" themselves to a previous spring\n\n    let target = attach && attach(this); // Reset merged props when necessary\n\n    let extra = reset ? {} : this.merged; // This will collect all props that were ever set\n\n    this.merged = _extends({}, from, extra, to); // Reduces input { name: value } pairs into animated values\n\n    this.animations = Object.entries(this.merged).reduce((acc, _ref3, i) => {\n      let name = _ref3[0],\n          value = _ref3[1]; // Issue cached entries, except on reset\n\n      let entry = !reset && acc[name] || {}; // Figure out what the value is supposed to be\n\n      const isNumber = typeof value === 'number';\n      const isString = typeof value === 'string' && !value.startsWith('#') && !/\\d/.test(value) && !colorNames[value];\n      const isArray = !isNumber && !isString && Array.isArray(value);\n      let fromValue = from[name] !== undefined ? from[name] : value;\n      let toValue = isNumber || isArray ? value : isString ? value : 1;\n      let toConfig = callProp(config, name);\n      if (target) toValue = target.animations[name].parent; // Detect changes, animated values will be checked in the raf-loop\n\n      if (toConfig.decay !== void 0 || !shallowEqual(entry.changes, value)) {\n        this.hasChanged = true;\n        let parent, interpolation$$1;\n        if (isNumber || isString) parent = interpolation$$1 = entry.parent || new AnimatedValue(fromValue);else if (isArray) parent = interpolation$$1 = entry.parent || new AnimatedArray(fromValue);else {\n          const prev = entry.interpolation && entry.interpolation.calc(entry.parent.value);\n\n          if (entry.parent) {\n            parent = entry.parent;\n            parent.setValue(0, false);\n          } else parent = new AnimatedValue(0);\n\n          const range = {\n            output: [prev !== void 0 ? prev : fromValue, value]\n          };\n\n          if (entry.interpolation) {\n            interpolation$$1 = entry.interpolation;\n            entry.interpolation.updateConfig(range);\n          } else interpolation$$1 = parent.interpolate(range);\n        } // Set immediate values\n\n        if (callProp(immediate, name)) parent.setValue(value, false); // Reset animated values\n\n        const animatedValues = toArray(parent.getPayload());\n        animatedValues.forEach(value => value.prepare(this));\n        return _extends({}, acc, {\n          [name]: _extends({}, entry, {\n            name,\n            parent,\n            interpolation: interpolation$$1,\n            animatedValues,\n            changes: value,\n            fromValues: toArray(parent.getValue()),\n            toValues: toArray(target ? toValue.getPayload() : toValue),\n            immediate: callProp(immediate, name),\n            delay: withDefault(toConfig.delay, delay || 0),\n            initialVelocity: withDefault(toConfig.velocity, 0),\n            clamp: withDefault(toConfig.clamp, false),\n            precision: withDefault(toConfig.precision, 0.01),\n            tension: withDefault(toConfig.tension, 170),\n            friction: withDefault(toConfig.friction, 26),\n            mass: withDefault(toConfig.mass, 1),\n            duration: toConfig.duration,\n            easing: withDefault(toConfig.easing, t => t),\n            decay: toConfig.decay\n          })\n        });\n      } else return acc;\n    }, this.animations);\n\n    if (this.hasChanged) {\n      this.configs = getValues$1(this.animations);\n      this.animatedProps = {};\n      this.interpolations = {};\n\n      for (let key in this.animations) {\n        this.interpolations[key] = this.animations[key].interpolation;\n        this.animatedProps[key] = this.animations[key].interpolation.getValue();\n      }\n    } // TODO: clean up ref in controller\n\n\n    for (var _len = arguments.length, start = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      start[_key - 1] = arguments[_key];\n    }\n\n    if (!ref && (autoStart || start.length)) this.start(...start);\n    const onEnd = start[0],\n          onUpdate = start[1];\n    this.onEnd = typeof onEnd === 'function' && onEnd;\n    this.onUpdate = onUpdate;\n    return this.getValues();\n  }\n\n  start(onEnd, onUpdate) {\n    this.startTime = now();\n    if (this.isActive) this.stop();\n    this.isActive = true;\n    this.onEnd = typeof onEnd === 'function' && onEnd;\n    this.onUpdate = onUpdate;\n    if (this.props.onStart) this.props.onStart();\n    addController(this);\n    return new Promise(res => this.resolve = res);\n  }\n\n  stop(finished) {\n    if (finished === void 0) {\n      finished = false;\n    } // Reset collected changes since the animation has been stopped cold turkey\n\n\n    if (finished) getValues$1(this.animations).forEach(a => a.changes = undefined);\n    this.debouncedOnEnd({\n      finished\n    });\n  }\n\n  destroy() {\n    removeController(this);\n    this.props = {};\n    this.merged = {};\n    this.animations = {};\n    this.interpolations = {};\n    this.animatedProps = {};\n    this.configs = [];\n  }\n\n  debouncedOnEnd(result) {\n    removeController(this);\n    this.isActive = false;\n    const onEnd = this.onEnd;\n    this.onEnd = null;\n    if (onEnd) onEnd(result);\n    if (this.resolve) this.resolve();\n    this.resolve = null;\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObjectWithChildren {\n  constructor(props, callback) {\n    super();\n    if (props.style) props = _extends({}, props, {\n      style: createAnimatedStyle(props.style)\n    });\n    this.payload = props;\n    this.update = callback;\n    this.attach();\n  }\n\n}\n\nfunction createAnimatedComponent(Component) {\n  class AnimatedComponent extends React__default.Component {\n    constructor(props) {\n      super();\n\n      this.callback = () => {\n        if (this.node) {\n          const didUpdate = applyAnimatedValues.fn(this.node, this.propsAnimated.getAnimatedValue(), this);\n          if (didUpdate === false) this.forceUpdate();\n        }\n      };\n\n      this.attachProps(props);\n    }\n\n    componentWillUnmount() {\n      this.propsAnimated && this.propsAnimated.detach();\n    }\n\n    setNativeProps(props) {\n      const didUpdate = applyAnimatedValues.fn(this.node, props, this);\n      if (didUpdate === false) this.forceUpdate();\n    } // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that\n    // changed. However, setNativeProps can only be implemented on leaf\n    // native components. If you want to animate a composite component, you\n    // need to re-render it. In this case, we have a fallback that uses\n    // forceUpdate.\n\n\n    attachProps(_ref) {\n      let forwardRef = _ref.forwardRef,\n          nextProps = _objectWithoutPropertiesLoose(_ref, [\"forwardRef\"]);\n\n      const oldPropsAnimated = this.propsAnimated;\n      this.propsAnimated = new AnimatedProps(nextProps, this.callback); // When you call detach, it removes the element from the parent list\n      // of children. If it goes to 0, then the parent also detaches itself\n      // and so on.\n      // An optimization is to attach the new elements and THEN detach the old\n      // ones instead of detaching and THEN attaching.\n      // This way the intermediate state isn't to go to 0 and trigger\n      // this expensive recursive detaching to then re-attach everything on\n      // the very next operation.\n\n      oldPropsAnimated && oldPropsAnimated.detach();\n    }\n\n    shouldComponentUpdate(props) {\n      const style = props.style,\n            nextProps = _objectWithoutPropertiesLoose(props, [\"style\"]);\n\n      const _this$props = this.props,\n            currentStyle = _this$props.style,\n            currentProps = _objectWithoutPropertiesLoose(_this$props, [\"style\"]);\n\n      if (!shallowEqual(currentProps, nextProps) || !shallowEqual(currentStyle, style)) {\n        this.attachProps(props);\n        return true;\n      }\n\n      return false;\n    }\n\n    render() {\n      const _this$propsAnimated$g = this.propsAnimated.getValue(),\n            scrollTop = _this$propsAnimated$g.scrollTop,\n            scrollLeft = _this$propsAnimated$g.scrollLeft,\n            animatedProps = _objectWithoutPropertiesLoose(_this$propsAnimated$g, [\"scrollTop\", \"scrollLeft\"]);\n\n      return React__default.createElement(Component, _extends({}, animatedProps, {\n        ref: node => this.node = handleRef(node, this.props.forwardRef)\n      }));\n    }\n\n  }\n\n  return React__default.forwardRef((props, ref) => React__default.createElement(AnimatedComponent, _extends({}, props, {\n    forwardRef: ref\n  })));\n}\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nclass Spring extends React__default.Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      lastProps: {\n        from: {},\n        to: {}\n      },\n      propsChanged: false,\n      internal: false\n    };\n    this.controller = new Controller(null, null);\n    this.didUpdate = false;\n    this.didInject = false;\n    this.finished = true;\n\n    this.start = () => {\n      this.finished = false;\n      let wasMounted = this.mounted;\n      this.controller.start(props => this.finish(_extends({}, props, {\n        wasMounted\n      })), this.update);\n    };\n\n    this.stop = () => this.controller.stop(true);\n\n    this.update = () => this.mounted && this.setState({\n      internal: true\n    });\n\n    this.finish = _ref => {\n      let finished = _ref.finished,\n          noChange = _ref.noChange,\n          wasMounted = _ref.wasMounted;\n      this.finished = true;\n\n      if (this.mounted && finished) {\n        // Only call onRest if either we *were* mounted, or when there were changes\n        if (this.props.onRest && (wasMounted || !noChange)) this.props.onRest(this.controller.merged); // Restore end-state\n\n        if (this.mounted && this.didInject) {\n          this.afterInject = convertValues(this.props);\n          this.setState({\n            internal: true\n          });\n        } // If we have an inject or values to apply after the animation we ping here\n\n\n        if (this.mounted && (this.didInject || this.props.after)) this.setState({\n          internal: true\n        });\n        this.didInject = false;\n      }\n    };\n  }\n\n  componentDidMount() {\n    // componentDidUpdate isn't called on mount, we call it here to start animating\n    this.componentDidUpdate();\n    this.mounted = true;\n  }\n\n  componentWillUnmount() {\n    // Stop all ongoing animtions\n    this.mounted = false;\n    this.stop();\n  }\n\n  static getDerivedStateFromProps(props, _ref2) {\n    let internal = _ref2.internal,\n        lastProps = _ref2.lastProps; // The following is a test against props that could alter the animation\n\n    const from = props.from,\n          to = props.to,\n          reset = props.reset,\n          force = props.force;\n    const propsChanged = !shallowEqual(to, lastProps.to) || !shallowEqual(from, lastProps.from) || reset && !internal || force && !internal;\n    return {\n      propsChanged,\n      lastProps: props,\n      internal: false\n    };\n  }\n\n  render() {\n    const children = this.props.children;\n    const propsChanged = this.state.propsChanged; // Inject phase -----------------------------------------------------------\n    // Handle injected frames, for instance targets/web/fix-auto\n    // An inject will return an intermediary React node which measures itself out\n    // .. and returns a callback when the values sought after are ready, usually \"auto\".\n\n    if (this.props.inject && propsChanged && !this.injectProps) {\n      const frame = this.props.inject(this.props, injectProps => {\n        // The inject frame has rendered, now let's update animations...\n        this.injectProps = injectProps;\n        this.setState({\n          internal: true\n        });\n      }); // Render out injected frame\n\n      if (frame) return frame;\n    } // Update phase -----------------------------------------------------------\n\n\n    if (this.injectProps || propsChanged) {\n      // We can potentially cause setState, but we're inside render, the flag prevents that\n      this.didInject = false; // Update animations, this turns from/to props into AnimatedValues\n      // An update can occur on injected props, or when own-props have changed.\n\n      if (this.injectProps) {\n        this.controller.update(this.injectProps); // didInject is needed, because there will be a 3rd stage, where the original values\n        // .. will be restored after the animation is finished. When someone animates towards\n        // .. \"auto\", the end-result should be \"auto\", not \"1999px\", which would block nested\n        // .. height/width changes.\n\n        this.didInject = true;\n      } else if (propsChanged) this.controller.update(this.props); // Flag an update that occured, componentDidUpdate will start the animation later on\n\n\n      this.didUpdate = true;\n      this.afterInject = undefined;\n      this.injectProps = undefined;\n    } // Render phase -----------------------------------------------------------\n    // Render out raw values or AnimatedValues depending on \"native\"\n\n\n    let values = _extends({}, this.controller.getValues(), this.afterInject);\n\n    if (this.finished) values = _extends({}, values, this.props.after);\n    return Object.keys(values).length ? children(values) : null;\n  }\n\n  componentDidUpdate() {\n    // The animation has to start *after* render, since at that point the scene\n    // .. graph should be established, so we do it here. Unfortunatelly, non-native\n    // .. animations as well as \"auto\"-injects call forceUpdate, so it's causing a loop.\n    // .. didUpdate prevents that as it gets set only on prop changes.\n    if (this.didUpdate) this.start();\n    this.didUpdate = false;\n  }\n\n}\n\nSpring.defaultProps = {\n  from: {},\n  to: {},\n  config: config.default,\n  native: false,\n  immediate: false,\n  reset: false,\n  force: false,\n  inject: bugfixes\n};\n\nclass Trail extends React__default.PureComponent {\n  constructor() {\n    super(...arguments);\n    this.first = true;\n    this.instances = new Set();\n\n    this.hook = (instance, index, length, reverse) => {\n      // Add instance to set\n      this.instances.add(instance); // Return undefined on the first index and from then on the previous instance\n\n      if (reverse ? index === length - 1 : index === 0) return undefined;else return Array.from(this.instances)[reverse ? index + 1 : index - 1];\n    };\n  }\n\n  render() {\n    const _this$props = this.props,\n          items = _this$props.items,\n          _children = _this$props.children,\n          _this$props$from = _this$props.from,\n          from = _this$props$from === void 0 ? {} : _this$props$from,\n          initial = _this$props.initial,\n          reverse = _this$props.reverse,\n          keys = _this$props.keys,\n          delay = _this$props.delay,\n          onRest = _this$props.onRest,\n          props = _objectWithoutPropertiesLoose(_this$props, [\"items\", \"children\", \"from\", \"initial\", \"reverse\", \"keys\", \"delay\", \"onRest\"]);\n\n    const array = toArray(items);\n    return toArray(array).map((item, i) => React__default.createElement(Spring, _extends({\n      onRest: i === 0 ? onRest : null,\n      key: typeof keys === 'function' ? keys(item) : toArray(keys)[i],\n      from: this.first && initial !== void 0 ? initial || {} : from\n    }, props, {\n      delay: i === 0 && delay || undefined,\n      attach: instance => this.hook(instance, i, array.length, reverse),\n      children: props => {\n        const child = _children(item, i);\n\n        return child ? child(props) : null;\n      }\n    })));\n  }\n\n  componentDidUpdate(prevProps) {\n    this.first = false;\n    if (prevProps.items !== this.props.items) this.instances.clear();\n  }\n\n}\n\nTrail.defaultProps = {\n  keys: item => item\n};\nconst DEFAULT = '__default';\n\nclass KeyframesImpl extends React__default.PureComponent {\n  constructor() {\n    var _this;\n\n    super(...arguments);\n    _this = this;\n    this.guid = 0;\n    this.state = {\n      props: {},\n      resolve: () => null,\n      last: true,\n      index: 0\n    };\n\n    this.next = function (props, last, index) {\n      if (last === void 0) {\n        last = true;\n      }\n\n      if (index === void 0) {\n        index = 0;\n      }\n\n      _this.running = true;\n      return new Promise(resolve => {\n        _this.mounted && _this.setState(state => ({\n          props,\n          resolve,\n          last,\n          index\n        }), () => _this.running = false);\n      });\n    };\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n    this.componentDidUpdate({});\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  componentDidUpdate(previous) {\n    var _this2 = this;\n\n    const _this$props = this.props,\n          states = _this$props.states,\n          f = _this$props.filter,\n          state = _this$props.state;\n\n    if (previous.state !== this.props.state || this.props.reset && !this.running || !shallowEqual(states[state], previous.states[previous.state])) {\n      if (states && state && states[state]) {\n        const localId = ++this.guid;\n        const slots = states[state];\n\n        if (slots) {\n          if (Array.isArray(slots)) {\n            let q = Promise.resolve();\n\n            for (let i = 0; i < slots.length; i++) {\n              let index = i;\n              let slot = slots[index];\n              let last = index === slots.length - 1;\n              q = q.then(() => localId === this.guid && this.next(f(slot), last, index));\n            }\n          } else if (typeof slots === 'function') {\n            let index = 0;\n            slots( // next\n            function (props, last) {\n              if (last === void 0) {\n                last = false;\n              }\n\n              return localId === _this2.guid && _this2.next(f(props), last, index++);\n            }, // cancel\n            () => requestFrame(() => this.instance && this.instance.stop()), // ownprops\n            this.props);\n          } else {\n            this.next(f(states[state]));\n          }\n        }\n      }\n    }\n  }\n\n  render() {\n    const _this$state = this.state,\n          props = _this$state.props,\n          resolve = _this$state.resolve,\n          last = _this$state.last,\n          index = _this$state.index;\n    if (!props || Object.keys(props).length === 0) return null;\n\n    let _this$props2 = this.props,\n        state = _this$props2.state,\n        filter = _this$props2.filter,\n        states = _this$props2.states,\n        config = _this$props2.config,\n        Component = _this$props2.primitive,\n        _onRest = _this$props2.onRest,\n        forwardRef = _this$props2.forwardRef,\n        rest = _objectWithoutPropertiesLoose(_this$props2, [\"state\", \"filter\", \"states\", \"config\", \"primitive\", \"onRest\", \"forwardRef\"]); // Arrayed configs need an index to process\n\n\n    if (Array.isArray(config)) config = config[index];\n    return React__default.createElement(Component, _extends({\n      ref: _ref => this.instance = handleRef(_ref, forwardRef),\n      config: config\n    }, rest, props, {\n      onRest: args => {\n        resolve(args);\n        if (_onRest && last) _onRest(args);\n      }\n    }));\n  }\n\n}\n\nKeyframesImpl.defaultProps = {\n  state: DEFAULT\n};\nconst Keyframes = React__default.forwardRef((props, ref) => React__default.createElement(KeyframesImpl, _extends({}, props, {\n  forwardRef: ref\n})));\n\nKeyframes.create = primitive => function (states, filter) {\n  if (filter === void 0) {\n    filter = states => states;\n  }\n\n  if (typeof states === 'function' || Array.isArray(states)) states = {\n    [DEFAULT]: states\n  };\n  return props => React__default.createElement(KeyframesImpl, _extends({\n    primitive: primitive,\n    states: states,\n    filter: filter\n  }, props));\n};\n\nKeyframes.Spring = states => Keyframes.create(Spring)(states, interpolateTo);\n\nKeyframes.Trail = states => Keyframes.create(Trail)(states, interpolateTo);\n\nlet guid = 0;\n\nlet get = props => {\n  let items = props.items,\n      keys = props.keys,\n      rest = _objectWithoutPropertiesLoose(props, [\"items\", \"keys\"]);\n\n  items = toArray(items !== void 0 ? items : null);\n  keys = typeof keys === 'function' ? items.map(keys) : toArray(keys); // Make sure numeric keys are interpreted as Strings (5 !== \"5\")\n\n  return _extends({\n    items,\n    keys: keys.map(key => String(key))\n  }, rest);\n};\n\nclass Transition extends React__default.PureComponent {\n  componentDidMount() {\n    this.mounted = true;\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  constructor(prevProps) {\n    super(prevProps);\n\n    this.destroyItem = (item, key, state) => values => {\n      const _this$props = this.props,\n            onRest = _this$props.onRest,\n            onDestroyed = _this$props.onDestroyed;\n\n      if (this.mounted) {\n        onDestroyed && onDestroyed(item);\n        this.setState(_ref => {\n          let deleted = _ref.deleted;\n          return {\n            deleted: deleted.filter(t => t.key !== key)\n          };\n        });\n        onRest && onRest(item, state, values);\n      }\n    };\n\n    this.state = {\n      first: true,\n      transitions: [],\n      current: {},\n      deleted: [],\n      prevProps\n    };\n  }\n\n  static getDerivedStateFromProps(props, _ref2) {\n    let first = _ref2.first,\n        prevProps = _ref2.prevProps,\n        state = _objectWithoutPropertiesLoose(_ref2, [\"first\", \"prevProps\"]);\n\n    let _get = get(props),\n        items = _get.items,\n        keys = _get.keys,\n        initial = _get.initial,\n        from = _get.from,\n        enter = _get.enter,\n        leave = _get.leave,\n        update = _get.update,\n        _get$trail = _get.trail,\n        trail = _get$trail === void 0 ? 0 : _get$trail,\n        unique = _get.unique,\n        config = _get.config;\n\n    let _get2 = get(prevProps),\n        _keys = _get2.keys,\n        _items = _get2.items;\n\n    let current = _extends({}, state.current);\n\n    let deleted = [...state.deleted]; // Compare next keys with current keys\n\n    let currentKeys = Object.keys(current);\n    let currentSet = new Set(currentKeys);\n    let nextSet = new Set(keys);\n    let added = keys.filter(item => !currentSet.has(item));\n    let removed = state.transitions.filter(item => !item.destroyed && !nextSet.has(item.originalKey)).map(i => i.originalKey);\n    let updated = keys.filter(item => currentSet.has(item));\n    let delay = 0;\n    added.forEach(key => {\n      // In unique mode, remove fading out transitions if their key comes in again\n      if (unique && deleted.find(d => d.originalKey === key)) deleted = deleted.filter(t => t.originalKey !== key);\n      const keyIndex = keys.indexOf(key);\n      const item = items[keyIndex];\n      const state = 'enter';\n      current[key] = {\n        state,\n        originalKey: key,\n        key: unique ? String(key) : guid++,\n        item,\n        trail: delay = delay + trail,\n        config: callProp(config, item, state),\n        from: callProp(first ? initial !== void 0 ? initial || {} : from : from, item),\n        to: callProp(enter, item)\n      };\n    });\n    removed.forEach(key => {\n      const keyIndex = _keys.indexOf(key);\n\n      const item = _items[keyIndex];\n      const state = 'leave';\n      deleted.push(_extends({}, current[key], {\n        state,\n        destroyed: true,\n        left: _keys[Math.max(0, keyIndex - 1)],\n        right: _keys[Math.min(_keys.length, keyIndex + 1)],\n        trail: delay = delay + trail,\n        config: callProp(config, item, state),\n        to: callProp(leave, item)\n      }));\n      delete current[key];\n    });\n    updated.forEach(key => {\n      const keyIndex = keys.indexOf(key);\n      const item = items[keyIndex];\n      const state = 'update';\n      current[key] = _extends({}, current[key], {\n        item,\n        state,\n        trail: delay = delay + trail,\n        config: callProp(config, item, state),\n        to: callProp(update, item)\n      });\n    }); // This tries to restore order for deleted items by finding their last known siblings\n\n    let out = keys.map(key => current[key]);\n    deleted.forEach(_ref3 => {\n      let left = _ref3.left,\n          right = _ref3.right,\n          transition = _objectWithoutPropertiesLoose(_ref3, [\"left\", \"right\"]);\n\n      let pos; // Was it the element on the left, if yes, move there ...\n\n      if ((pos = out.findIndex(t => t.originalKey === left)) !== -1) pos += 1; // Or how about the element on the right ...\n\n      if (pos === -1) pos = out.findIndex(t => t.originalKey === right); // Maybe we'll find it in the list of deleted items\n\n      if (pos === -1) pos = deleted.findIndex(t => t.originalKey === left); // Checking right side as well\n\n      if (pos === -1) pos = deleted.findIndex(t => t.originalKey === right); // And if nothing else helps, move it to the start ¯\\_(ツ)_/¯\n\n      pos = Math.max(0, pos);\n      out = [...out.slice(0, pos), transition, ...out.slice(pos)];\n    });\n    return {\n      first: first && added.length === 0,\n      transitions: out,\n      current,\n      deleted,\n      prevProps: props\n    };\n  }\n\n  render() {\n    const _this$props2 = this.props,\n          initial = _this$props2.initial,\n          _this$props2$from = _this$props2.from,\n          _this$props2$enter = _this$props2.enter,\n          _this$props2$leave = _this$props2.leave,\n          _this$props2$update = _this$props2.update,\n          onDestroyed = _this$props2.onDestroyed,\n          keys = _this$props2.keys,\n          items = _this$props2.items,\n          onFrame = _this$props2.onFrame,\n          onRest = _this$props2.onRest,\n          onStart = _this$props2.onStart,\n          trail = _this$props2.trail,\n          config = _this$props2.config,\n          _children = _this$props2.children,\n          unique = _this$props2.unique,\n          reset = _this$props2.reset,\n          extra = _objectWithoutPropertiesLoose(_this$props2, [\"initial\", \"from\", \"enter\", \"leave\", \"update\", \"onDestroyed\", \"keys\", \"items\", \"onFrame\", \"onRest\", \"onStart\", \"trail\", \"config\", \"children\", \"unique\", \"reset\"]);\n\n    return this.state.transitions.map((_ref4, i) => {\n      let state = _ref4.state,\n          key = _ref4.key,\n          item = _ref4.item,\n          from = _ref4.from,\n          to = _ref4.to,\n          trail = _ref4.trail,\n          config = _ref4.config,\n          destroyed = _ref4.destroyed;\n      return React__default.createElement(Keyframes, _extends({\n        reset: reset && state === 'enter',\n        primitive: Spring,\n        state: state,\n        filter: interpolateTo,\n        states: {\n          [state]: to\n        },\n        key: key,\n        onRest: destroyed ? this.destroyItem(item, key, state) : onRest && (values => onRest(item, state, values)),\n        onStart: onStart && (() => onStart(item, state)),\n        onFrame: onFrame && (values => onFrame(item, state, values)),\n        delay: trail,\n        config: config\n      }, extra, {\n        from: from,\n        children: props => {\n          const child = _children(item, state, i);\n\n          return child ? child(props) : null;\n        }\n      }));\n    });\n  }\n\n}\n\nTransition.defaultProps = {\n  keys: item => item,\n  unique: false,\n  reset: false\n}; // Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662\n\nconst stringShapeRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n\nfunction createInterpolation(config$$1) {\n  const outputRange = config$$1.output;\n  const outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);\n  outputRange.forEach(value => {\n    value.match(stringShapeRegex).forEach((number, i) => outputRanges[i].push(+number));\n  });\n  const interpolations = outputRange[0].match(stringShapeRegex).map((_, i) => Interpolation.create(_extends({}, config$$1, {\n    output: outputRanges[i]\n  })));\n  return input => {\n    let i = 0;\n    return outputRange[0].replace(stringShapeRegex, () => interpolations[i++](input));\n  };\n} // Render 30/fps by default\n\n\ninjectFrame(cb => setTimeout(cb, 1000 / 30), r => clearTimeout(r));\ninjectInterpolation(createInterpolation);\ninjectApplyAnimatedValues(() => false, style => style);\nexports.Spring = Spring;\nexports.Keyframes = Keyframes;\nexports.Transition = Transition;\nexports.Trail = Trail;\nexports.Controller = Controller;\nexports.config = config;\nexports.animated = createAnimatedComponent;\nexports.interpolate = interpolate$1;\nexports.Globals = Globals;","map":{"version":3,"sources":["/Users/se/Documents/resume/dynamic_website/resume_website/src/node_modules/react-spring/renderprops-universal.js"],"names":["Object","defineProperty","exports","value","_interopDefault","ex","_extends","require","_objectWithoutPropertiesLoose","React","React__default","bugfixes","undefined","applyAnimatedValues","colorNames","requestFrame","cb","window","requestAnimationFrame","cancelFrame","cancelAnimationFrame","interpolation","now","Date","defaultElement","createAnimatedStyle","injectApplyAnimatedValues","fn","transform","injectColorNames","names","injectBugfixes","injectInterpolation","cls","injectFrame","raf","caf","_ref","injectNow","nowFn","injectDefaultElement","el","injectCreateAnimatedStyle","factory","Globals","freeze","Animated","attach","detach","getValue","getAnimatedValue","addChild","child","removeChild","getChildren","getValues","object","keys","map","k","AnimatedWithChildren","constructor","_this","arguments","children","getPayload","index","payload","length","push","indexOf","splice","AnimatedArrayWithChildren","forEach","p","AnimatedObjectWithChildren","s","animated","key","Interpolation","create","config","output","extra","Array","isArray","range","extrapolate","outputRange","inputRange","easing","t","extrapolateLeft","extrapolateRight","input","findRange","interpolate","inputMin","inputMax","outputMin","outputMax","result","Infinity","i","AnimatedInterpolation","parents","_config","_arg","calc","updateConfig","arg","interpolate$1","findAnimatedStyles","node","styles","update","add","AnimatedValue","_value","setValue","flush","updateStyles","animatedStyles","updateValue","Set","done","startPosition","lastPosition","lastVelocity","lastTime","controller","size","animatedStyle","prepare","isActive","clear","AnimatedArray","array","v","n","active","controllers","frameLoop","time","isDone","noChange","configIdx","configs","endOfAnimation","valIdx","animatedValues","animation","from","fromValues","to","toValues","position","isAnimated","velocity","initialVelocity","immediate","decay","delay","startTime","duration","Math","exp","abs","numSteps","floor","force","tension","damping","friction","acceleration","mass","isOvershooting","clamp","isVelocity","precision","isDisplacement","props","onFrame","native","animatedProps","name","onUpdate","delete","debouncedOnEnd","finished","addController","has","removeController","withDefault","defaultValue","toArray","a","shallowEqual","b","callProp","obj","_len","args","_key","getValues$1","getForwardProps","onStart","onRest","reset","reverse","impl","inject","destroyed","interpolateTo","autoStart","ref","forward","rest","reduce","convertToAnimatedValue","acc","convertValues","allProps","entries","handleRef","current","Controller","interpolations","dependents","hasChanged","merged","animations","frame","_ref$from","_ref$to","_ref$config","_ref$delay","_ref2","target","_ref3","entry","isNumber","isString","startsWith","test","fromValue","toValue","toConfig","parent","changes","interpolation$$1","prev","start","onEnd","stop","Promise","res","resolve","destroy","AnimatedProps","callback","style","createAnimatedComponent","Component","AnimatedComponent","didUpdate","propsAnimated","forceUpdate","attachProps","componentWillUnmount","setNativeProps","forwardRef","nextProps","oldPropsAnimated","shouldComponentUpdate","_this$props","currentStyle","currentProps","render","_this$propsAnimated$g","scrollTop","scrollLeft","createElement","default","gentle","wobbly","stiff","slow","molasses","Spring","state","lastProps","propsChanged","internal","didInject","wasMounted","mounted","finish","setState","afterInject","after","componentDidMount","componentDidUpdate","getDerivedStateFromProps","injectProps","values","defaultProps","Trail","PureComponent","first","instances","hook","instance","items","_children","_this$props$from","initial","item","prevProps","DEFAULT","KeyframesImpl","guid","last","next","running","previous","_this2","states","f","filter","localId","slots","q","slot","then","_this$state","_this$props2","primitive","_onRest","Keyframes","get","String","Transition","destroyItem","onDestroyed","deleted","transitions","_get","enter","leave","_get$trail","trail","unique","_get2","_keys","_items","currentKeys","currentSet","nextSet","added","removed","originalKey","updated","find","d","keyIndex","left","max","right","min","out","transition","pos","findIndex","slice","_this$props2$from","_this$props2$enter","_this$props2$leave","_this$props2$update","_ref4","stringShapeRegex","createInterpolation","config$$1","outputRanges","match","number","_","replace","setTimeout","r","clearTimeout"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar _extends = _interopDefault(require('@babel/runtime/helpers/esm/extends'));\nvar _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/esm/objectWithoutPropertiesLoose'));\nvar React = require('react');\nvar React__default = _interopDefault(React);\n\nlet bugfixes = undefined;\nlet applyAnimatedValues = undefined;\nlet colorNames = [];\nlet requestFrame = cb => typeof window !== 'undefined' && window.requestAnimationFrame(cb);\nlet cancelFrame = cb => typeof window !== 'undefined' && window.cancelAnimationFrame(cb);\nlet interpolation = undefined;\nlet now = () => Date.now();\nlet defaultElement = undefined;\nlet createAnimatedStyle = undefined;\nconst injectApplyAnimatedValues = (fn, transform) => applyAnimatedValues = {\n  fn,\n  transform\n};\nconst injectColorNames = names => colorNames = names;\nconst injectBugfixes = fn => bugfixes = fn;\nconst injectInterpolation = cls => interpolation = cls;\nconst injectFrame = (raf, caf) => {\n  var _ref = [raf, caf];\n  requestFrame = _ref[0];\n  cancelFrame = _ref[1];\n  return _ref;\n};\nconst injectNow = nowFn => now = nowFn;\nconst injectDefaultElement = el => defaultElement = el;\nconst injectCreateAnimatedStyle = factory => createAnimatedStyle = factory;\n\nvar Globals = /*#__PURE__*/Object.freeze({\n  get bugfixes () { return bugfixes; },\n  get applyAnimatedValues () { return applyAnimatedValues; },\n  get colorNames () { return colorNames; },\n  get requestFrame () { return requestFrame; },\n  get cancelFrame () { return cancelFrame; },\n  get interpolation () { return interpolation; },\n  get now () { return now; },\n  get defaultElement () { return defaultElement; },\n  get createAnimatedStyle () { return createAnimatedStyle; },\n  injectApplyAnimatedValues: injectApplyAnimatedValues,\n  injectColorNames: injectColorNames,\n  injectBugfixes: injectBugfixes,\n  injectInterpolation: injectInterpolation,\n  injectFrame: injectFrame,\n  injectNow: injectNow,\n  injectDefaultElement: injectDefaultElement,\n  injectCreateAnimatedStyle: injectCreateAnimatedStyle\n});\n\nclass Animated {\n  attach() {}\n\n  detach() {}\n\n  getValue() {}\n\n  getAnimatedValue() {\n    return this.getValue();\n  }\n\n  addChild(child) {}\n\n  removeChild(child) {}\n\n  getChildren() {\n    return [];\n  }\n\n}\n\nconst getValues = object => Object.keys(object).map(k => object[k]);\n\nclass AnimatedWithChildren extends Animated {\n  constructor() {\n    var _this;\n\n    super(...arguments);\n    _this = this;\n    this.children = [];\n\n    this.getChildren = () => this.children;\n\n    this.getPayload = function (index) {\n      if (index === void 0) {\n        index = undefined;\n      }\n\n      return index !== void 0 && _this.payload ? _this.payload[index] : _this.payload || _this;\n    };\n  }\n\n  addChild(child) {\n    if (this.children.length === 0) this.attach();\n    this.children.push(child);\n  }\n\n  removeChild(child) {\n    const index = this.children.indexOf(child);\n    this.children.splice(index, 1);\n    if (this.children.length === 0) this.detach();\n  }\n\n}\nclass AnimatedArrayWithChildren extends AnimatedWithChildren {\n  constructor() {\n    super(...arguments);\n    this.payload = [];\n\n    this.getAnimatedValue = () => this.getValue();\n\n    this.attach = () => this.payload.forEach(p => p instanceof Animated && p.addChild(this));\n\n    this.detach = () => this.payload.forEach(p => p instanceof Animated && p.removeChild(this));\n  }\n\n}\nclass AnimatedObjectWithChildren extends AnimatedWithChildren {\n  constructor() {\n    super(...arguments);\n    this.payload = {};\n\n    this.getAnimatedValue = () => this.getValue(true);\n\n    this.attach = () => getValues(this.payload).forEach(s => s instanceof Animated && s.addChild(this));\n\n    this.detach = () => getValues(this.payload).forEach(s => s instanceof Animated && s.removeChild(this));\n  }\n\n  getValue(animated) {\n    if (animated === void 0) {\n      animated = false;\n    }\n\n    const payload = {};\n\n    for (const key in this.payload) {\n      const value = this.payload[key];\n      if (animated && !(value instanceof Animated)) continue;\n      payload[key] = value instanceof Animated ? value[animated ? 'getAnimatedValue' : 'getValue']() : value;\n    }\n\n    return payload;\n  }\n\n}\n\nclass Interpolation {\n  // Default config = config, args\n  // Short config   = range, output, extrapolate\n  static create(config, output, extra) {\n    if (typeof config === 'function') return config;else if (interpolation && config.output && typeof config.output[0] === 'string') return interpolation(config);else if (Array.isArray(config)) return Interpolation.create({\n      range: config,\n      output,\n      extrapolate: extra || 'extend'\n    });\n    let outputRange = config.output;\n    let inputRange = config.range || [0, 1];\n\n    let easing = config.easing || (t => t);\n\n    let extrapolateLeft = 'extend';\n    let map = config.map;\n    if (config.extrapolateLeft !== undefined) extrapolateLeft = config.extrapolateLeft;else if (config.extrapolate !== undefined) extrapolateLeft = config.extrapolate;\n    let extrapolateRight = 'extend';\n    if (config.extrapolateRight !== undefined) extrapolateRight = config.extrapolateRight;else if (config.extrapolate !== undefined) extrapolateRight = config.extrapolate;\n    return input => {\n      let range = findRange(input, inputRange);\n      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight, map);\n    };\n  }\n\n}\n\nfunction interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {\n  let result = map ? map(input) : input; // Extrapolate\n\n  if (result < inputMin) {\n    if (extrapolateLeft === 'identity') return result;else if (extrapolateLeft === 'clamp') result = inputMin;\n  }\n\n  if (result > inputMax) {\n    if (extrapolateRight === 'identity') return result;else if (extrapolateRight === 'clamp') result = inputMax;\n  }\n\n  if (outputMin === outputMax) return outputMin;\n  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax; // Input Range\n\n  if (inputMin === -Infinity) result = -result;else if (inputMax === Infinity) result = result - inputMin;else result = (result - inputMin) / (inputMax - inputMin); // Easing\n\n  result = easing(result); // Output Range\n\n  if (outputMin === -Infinity) result = -result;else if (outputMax === Infinity) result = result + outputMin;else result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\n\nfunction findRange(input, inputRange) {\n  for (var i = 1; i < inputRange.length - 1; ++i) if (inputRange[i] >= input) break;\n\n  return i - 1;\n}\n\nclass AnimatedInterpolation extends AnimatedArrayWithChildren {\n  constructor(parents, _config, _arg) {\n    super();\n\n    this.getValue = () => this.calc(...this.payload.map(value => value.getValue()));\n\n    this.updateConfig = (config, arg) => this.calc = Interpolation.create(config, arg);\n\n    this.interpolate = (config, arg) => new AnimatedInterpolation(this, config, arg);\n\n    this.payload = // AnimatedArrays should unfold, except AnimatedInterpolation which is taken as is\n    parents instanceof AnimatedArrayWithChildren && !parents.updateConfig ? parents.payload : Array.isArray(parents) ? parents : [parents];\n    this.calc = Interpolation.create(_config, _arg);\n  }\n\n}\nconst interpolate$1 = (parents, config, arg) => parents && new AnimatedInterpolation(parents, config, arg);\n\n/**\n * Animated works by building a directed acyclic graph of dependencies\n * transparently when you render your Animated components.\n *\n *               new Animated.Value(0)\n *     .interpolate()        .interpolate()    new Animated.Value(1)\n *         opacity               translateY      scale\n *          style                         transform\n *         View#234                         style\n *                                         View#123\n *\n * A) Top Down phase\n * When an Animated.Value is updated, we recursively go down through this\n * graph in order to find leaf nodes: the views that we flag as needing\n * an update.\n *\n * B) Bottom Up phase\n * When a view is flagged as needing an update, we recursively go back up\n * in order to build the new value that it needs. The reason why we need\n * this two-phases process is to deal with composite props such as\n * transform which can receive values from multiple parents.\n */\n\nfunction findAnimatedStyles(node, styles) {\n  if (typeof node.update === 'function') styles.add(node);else node.getChildren().forEach(child => findAnimatedStyles(child, styles));\n}\n/**\n * Standard value for driving animations.  One `Animated.Value` can drive\n * multiple properties in a synchronized fashion, but can only be driven by one\n * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,\n * or calling `setValue`) will stop any previous ones.\n */\n\n\nclass AnimatedValue extends AnimatedWithChildren {\n  constructor(_value) {\n    var _this;\n\n    super();\n    _this = this;\n\n    this.setValue = function (value, flush) {\n      if (flush === void 0) {\n        flush = true;\n      }\n\n      _this.value = value;\n      if (flush) _this.flush();\n    };\n\n    this.getValue = () => this.value;\n\n    this.updateStyles = () => findAnimatedStyles(this, this.animatedStyles);\n\n    this.updateValue = value => this.flush(this.value = value);\n\n    this.interpolate = (config, arg) => new AnimatedInterpolation(this, config, arg);\n\n    this.value = _value;\n    this.animatedStyles = new Set();\n    this.done = false;\n    this.startPosition = _value;\n    this.lastPosition = _value;\n    this.lastVelocity = undefined;\n    this.lastTime = undefined;\n    this.controller = undefined;\n  }\n\n  flush() {\n    if (this.animatedStyles.size === 0) this.updateStyles();\n    this.animatedStyles.forEach(animatedStyle => animatedStyle.update());\n  }\n\n  prepare(controller) {\n    // Values stay loyal to their original controller, this is also a way to\n    // detect trailing values originating from a foreign controller\n    if (this.controller === undefined) this.controller = controller;\n\n    if (this.controller === controller) {\n      this.startPosition = this.value;\n      this.lastPosition = this.value;\n      this.lastVelocity = controller.isActive ? this.lastVelocity : undefined;\n      this.lastTime = controller.isActive ? this.lastTime : undefined;\n      this.done = false;\n      this.animatedStyles.clear();\n    }\n  }\n\n}\n\nclass AnimatedArray extends AnimatedArrayWithChildren {\n  constructor(array) {\n    var _this;\n\n    super();\n    _this = this;\n\n    this.setValue = function (value, flush) {\n      if (flush === void 0) {\n        flush = true;\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === _this.payload.length) value.forEach((v, i) => _this.payload[i].setValue(v, flush));\n      } else _this.payload.forEach((v, i) => _this.payload[i].setValue(value, flush));\n    };\n\n    this.getValue = () => this.payload.map(v => v.getValue());\n\n    this.interpolate = (config, arg) => new AnimatedInterpolation(this, config, arg);\n\n    this.payload = array.map(n => new AnimatedValue(n));\n  }\n\n}\n\nlet active = false;\nconst controllers = new Set();\n\nconst frameLoop = () => {\n  let time = now();\n\n  for (let controller of controllers) {\n    let isDone = true;\n    let noChange = true;\n\n    for (let configIdx = 0; configIdx < controller.configs.length; configIdx++) {\n      let config = controller.configs[configIdx];\n      let endOfAnimation, lastTime;\n\n      for (let valIdx = 0; valIdx < config.animatedValues.length; valIdx++) {\n        let animation = config.animatedValues[valIdx]; // If an animation is done, skip, until all of them conclude\n\n        if (animation.done) continue;\n        let from = config.fromValues[valIdx];\n        let to = config.toValues[valIdx];\n        let position = animation.lastPosition;\n        let isAnimated = to instanceof Animated;\n        let velocity = Array.isArray(config.initialVelocity) ? config.initialVelocity[valIdx] : config.initialVelocity;\n        if (isAnimated) to = to.getValue(); // Conclude animation if it's either immediate, or from-values match end-state\n\n        if (config.immediate || !isAnimated && !config.decay && from === to) {\n          animation.updateValue(to);\n          animation.done = true;\n          continue;\n        } // Doing delay here instead of setTimeout is one async worry less\n\n\n        if (config.delay && time - controller.startTime < config.delay) {\n          isDone = false;\n          continue;\n        } // Flag change\n\n\n        noChange = false; // Break animation when string values are involved\n\n        if (typeof from === 'string' || typeof to === 'string') {\n          animation.updateValue(to);\n          animation.done = true;\n          continue;\n        }\n\n        if (config.duration !== void 0) {\n          /** Duration easing */\n          position = from + config.easing((time - controller.startTime - config.delay) / config.duration) * (to - from);\n          endOfAnimation = time >= controller.startTime + config.delay + config.duration;\n        } else if (config.decay) {\n          /** Decay easing */\n          position = from + velocity / (1 - 0.998) * (1 - Math.exp(-(1 - 0.998) * (time - controller.startTime)));\n          endOfAnimation = Math.abs(animation.lastPosition - position) < 0.1;\n          if (endOfAnimation) to = position;\n        } else {\n          /** Spring easing */\n          lastTime = animation.lastTime !== void 0 ? animation.lastTime : time;\n          velocity = animation.lastVelocity !== void 0 ? animation.lastVelocity : config.initialVelocity; // If we lost a lot of frames just jump to the end.\n\n          if (time > lastTime + 64) lastTime = time; // http://gafferongames.com/game-physics/fix-your-timestep/\n\n          let numSteps = Math.floor(time - lastTime);\n\n          for (let i = 0; i < numSteps; ++i) {\n            let force = -config.tension * (position - to);\n            let damping = -config.friction * velocity;\n            let acceleration = (force + damping) / config.mass;\n            velocity = velocity + acceleration * 1 / 1000;\n            position = position + velocity * 1 / 1000;\n          } // Conditions for stopping the spring animation\n\n\n          let isOvershooting = config.clamp && config.tension !== 0 ? from < to ? position > to : position < to : false;\n          let isVelocity = Math.abs(velocity) <= config.precision;\n          let isDisplacement = config.tension !== 0 ? Math.abs(to - position) <= config.precision : true;\n          endOfAnimation = isOvershooting || isVelocity && isDisplacement;\n          animation.lastVelocity = velocity;\n          animation.lastTime = time;\n        } // Trails aren't done until their parents conclude\n\n\n        if (isAnimated && !config.toValues[valIdx].done) endOfAnimation = false;\n\n        if (endOfAnimation) {\n          // Ensure that we end up with a round value\n          if (animation.value !== to) position = to;\n          animation.done = true;\n        } else isDone = false;\n\n        animation.updateValue(position);\n        animation.lastPosition = position;\n      } // Keep track of updated values only when necessary\n\n\n      if (controller.props.onFrame || !controller.props.native) controller.animatedProps[config.name] = config.interpolation.getValue();\n    } // Update callbacks in the end of the frame\n\n\n    if (controller.props.onFrame || !controller.props.native) {\n      if (!controller.props.native && controller.onUpdate) controller.onUpdate();\n      if (controller.props.onFrame) controller.props.onFrame(controller.animatedProps);\n    } // Either call onEnd or next frame\n\n\n    if (isDone) {\n      controllers.delete(controller);\n      controller.debouncedOnEnd({\n        finished: true,\n        noChange\n      });\n    }\n  } // Loop over as long as there are controllers ...\n\n\n  if (controllers.size) requestFrame(frameLoop);else active = false;\n};\n\nconst addController = controller => {\n  if (!controllers.has(controller)) {\n    controllers.add(controller);\n    if (!active) requestFrame(frameLoop);\n    active = true;\n  }\n};\n\nconst removeController = controller => {\n  if (controllers.has(controller)) {\n    controllers.delete(controller);\n  }\n};\n\nfunction withDefault(value, defaultValue) {\n  return value === undefined || value === null ? defaultValue : value;\n}\nfunction toArray(a) {\n  return a !== void 0 ? Array.isArray(a) ? a : [a] : [];\n}\nfunction shallowEqual(a, b) {\n  if (typeof a !== typeof b) return false;\n  if (typeof a === 'string' || typeof a === 'number') return a === b;\n  let i;\n\n  for (i in a) if (!(i in b)) return false;\n\n  for (i in b) if (a[i] !== b[i]) return false;\n\n  return i === void 0 ? a === b : true;\n}\nfunction callProp(obj) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return typeof obj === 'function' ? obj(...args) : obj;\n}\nfunction getValues$1(object) {\n  return Object.keys(object).map(k => object[k]);\n}\nfunction getForwardProps(props) {\n  const to = props.to,\n        from = props.from,\n        config = props.config,\n        native = props.native,\n        onStart = props.onStart,\n        onRest = props.onRest,\n        onFrame = props.onFrame,\n        children = props.children,\n        reset = props.reset,\n        reverse = props.reverse,\n        force = props.force,\n        immediate = props.immediate,\n        impl = props.impl,\n        inject = props.inject,\n        delay = props.delay,\n        attach = props.attach,\n        destroyed = props.destroyed,\n        interpolateTo = props.interpolateTo,\n        autoStart = props.autoStart,\n        ref = props.ref,\n        forward = _objectWithoutPropertiesLoose(props, [\"to\", \"from\", \"config\", \"native\", \"onStart\", \"onRest\", \"onFrame\", \"children\", \"reset\", \"reverse\", \"force\", \"immediate\", \"impl\", \"inject\", \"delay\", \"attach\", \"destroyed\", \"interpolateTo\", \"autoStart\", \"ref\"]);\n\n  return forward;\n}\nfunction interpolateTo(props) {\n  const forward = getForwardProps(props);\n  const rest = Object.keys(props).reduce((a, k) => forward[k] !== void 0 ? a : _extends({}, a, {\n    [k]: props[k]\n  }), {});\n  return _extends({\n    to: forward\n  }, rest);\n}\nfunction convertToAnimatedValue(acc, _ref) {\n  let name = _ref[0],\n      value = _ref[1];\n  return _extends({}, acc, {\n    [name]: new (Array.isArray(value) ? AnimatedArray : AnimatedValue)(value)\n  });\n}\nfunction convertValues(props) {\n  const from = props.from,\n        to = props.to,\n        native = props.native;\n  const allProps = Object.entries(_extends({}, from, to));\n  return native ? allProps.reduce(convertToAnimatedValue, {}) : _extends({}, from, to);\n}\nfunction handleRef(ref, forward) {\n  if (forward) {\n    // If it's a function, assume it's a ref callback\n    if (typeof forward === 'function') forward(ref);else if (typeof forward === 'object') {\n      // If it's an object and has a 'current' property, assume it's a ref object\n      forward.current = ref;\n    }\n  }\n\n  return ref;\n}\n\nclass Controller {\n  constructor(props, config) {\n    if (config === void 0) {\n      config = {\n        native: true,\n        interpolateTo: true,\n        autoStart: true\n      };\n    }\n\n    this.getValues = () => this.props.native ? this.interpolations : this.animatedProps;\n\n    this.dependents = new Set();\n    this.isActive = false;\n    this.hasChanged = false;\n    this.props = {};\n    this.merged = {};\n    this.animations = {};\n    this.interpolations = {};\n    this.animatedProps = {};\n    this.configs = [];\n    this.frame = undefined;\n    this.startTime = undefined;\n    this.lastTime = undefined;\n    this.update(_extends({}, props, config));\n  }\n\n  update(props) {\n    this.props = _extends({}, this.props, props);\n\n    let _ref = this.props.interpolateTo ? interpolateTo(this.props) : this.props,\n        _ref$from = _ref.from,\n        from = _ref$from === void 0 ? {} : _ref$from,\n        _ref$to = _ref.to,\n        to = _ref$to === void 0 ? {} : _ref$to,\n        _ref$config = _ref.config,\n        config = _ref$config === void 0 ? {} : _ref$config,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay,\n        reverse = _ref.reverse,\n        attach = _ref.attach,\n        reset = _ref.reset,\n        immediate = _ref.immediate,\n        autoStart = _ref.autoStart,\n        ref = _ref.ref; // Reverse values when requested\n\n\n    if (reverse) {\n      var _ref2 = [to, from];\n      from = _ref2[0];\n      to = _ref2[1];\n    }\n\n    this.hasChanged = false; // Attachment handling, trailed springs can \"attach\" themselves to a previous spring\n\n    let target = attach && attach(this); // Reset merged props when necessary\n\n    let extra = reset ? {} : this.merged; // This will collect all props that were ever set\n\n    this.merged = _extends({}, from, extra, to); // Reduces input { name: value } pairs into animated values\n\n    this.animations = Object.entries(this.merged).reduce((acc, _ref3, i) => {\n      let name = _ref3[0],\n          value = _ref3[1];\n      // Issue cached entries, except on reset\n      let entry = !reset && acc[name] || {}; // Figure out what the value is supposed to be\n\n      const isNumber = typeof value === 'number';\n      const isString = typeof value === 'string' && !value.startsWith('#') && !/\\d/.test(value) && !colorNames[value];\n      const isArray = !isNumber && !isString && Array.isArray(value);\n      let fromValue = from[name] !== undefined ? from[name] : value;\n      let toValue = isNumber || isArray ? value : isString ? value : 1;\n      let toConfig = callProp(config, name);\n      if (target) toValue = target.animations[name].parent; // Detect changes, animated values will be checked in the raf-loop\n\n      if (toConfig.decay !== void 0 || !shallowEqual(entry.changes, value)) {\n        this.hasChanged = true;\n        let parent, interpolation$$1;\n        if (isNumber || isString) parent = interpolation$$1 = entry.parent || new AnimatedValue(fromValue);else if (isArray) parent = interpolation$$1 = entry.parent || new AnimatedArray(fromValue);else {\n          const prev = entry.interpolation && entry.interpolation.calc(entry.parent.value);\n\n          if (entry.parent) {\n            parent = entry.parent;\n            parent.setValue(0, false);\n          } else parent = new AnimatedValue(0);\n\n          const range = {\n            output: [prev !== void 0 ? prev : fromValue, value]\n          };\n\n          if (entry.interpolation) {\n            interpolation$$1 = entry.interpolation;\n            entry.interpolation.updateConfig(range);\n          } else interpolation$$1 = parent.interpolate(range);\n        } // Set immediate values\n\n        if (callProp(immediate, name)) parent.setValue(value, false); // Reset animated values\n\n        const animatedValues = toArray(parent.getPayload());\n        animatedValues.forEach(value => value.prepare(this));\n        return _extends({}, acc, {\n          [name]: _extends({}, entry, {\n            name,\n            parent,\n            interpolation: interpolation$$1,\n            animatedValues,\n            changes: value,\n            fromValues: toArray(parent.getValue()),\n            toValues: toArray(target ? toValue.getPayload() : toValue),\n            immediate: callProp(immediate, name),\n            delay: withDefault(toConfig.delay, delay || 0),\n            initialVelocity: withDefault(toConfig.velocity, 0),\n            clamp: withDefault(toConfig.clamp, false),\n            precision: withDefault(toConfig.precision, 0.01),\n            tension: withDefault(toConfig.tension, 170),\n            friction: withDefault(toConfig.friction, 26),\n            mass: withDefault(toConfig.mass, 1),\n            duration: toConfig.duration,\n            easing: withDefault(toConfig.easing, t => t),\n            decay: toConfig.decay\n          })\n        });\n      } else return acc;\n    }, this.animations);\n\n    if (this.hasChanged) {\n      this.configs = getValues$1(this.animations);\n      this.animatedProps = {};\n      this.interpolations = {};\n\n      for (let key in this.animations) {\n        this.interpolations[key] = this.animations[key].interpolation;\n        this.animatedProps[key] = this.animations[key].interpolation.getValue();\n      }\n    } // TODO: clean up ref in controller\n\n\n    for (var _len = arguments.length, start = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      start[_key - 1] = arguments[_key];\n    }\n\n    if (!ref && (autoStart || start.length)) this.start(...start);\n    const onEnd = start[0],\n          onUpdate = start[1];\n    this.onEnd = typeof onEnd === 'function' && onEnd;\n    this.onUpdate = onUpdate;\n    return this.getValues();\n  }\n\n  start(onEnd, onUpdate) {\n    this.startTime = now();\n    if (this.isActive) this.stop();\n    this.isActive = true;\n    this.onEnd = typeof onEnd === 'function' && onEnd;\n    this.onUpdate = onUpdate;\n    if (this.props.onStart) this.props.onStart();\n    addController(this);\n    return new Promise(res => this.resolve = res);\n  }\n\n  stop(finished) {\n    if (finished === void 0) {\n      finished = false;\n    }\n\n    // Reset collected changes since the animation has been stopped cold turkey\n    if (finished) getValues$1(this.animations).forEach(a => a.changes = undefined);\n    this.debouncedOnEnd({\n      finished\n    });\n  }\n\n  destroy() {\n    removeController(this);\n    this.props = {};\n    this.merged = {};\n    this.animations = {};\n    this.interpolations = {};\n    this.animatedProps = {};\n    this.configs = [];\n  }\n\n  debouncedOnEnd(result) {\n    removeController(this);\n    this.isActive = false;\n    const onEnd = this.onEnd;\n    this.onEnd = null;\n    if (onEnd) onEnd(result);\n    if (this.resolve) this.resolve();\n    this.resolve = null;\n  }\n\n}\n\nclass AnimatedProps extends AnimatedObjectWithChildren {\n  constructor(props, callback) {\n    super();\n    if (props.style) props = _extends({}, props, {\n      style: createAnimatedStyle(props.style)\n    });\n    this.payload = props;\n    this.update = callback;\n    this.attach();\n  }\n\n}\n\nfunction createAnimatedComponent(Component) {\n  class AnimatedComponent extends React__default.Component {\n    constructor(props) {\n      super();\n\n      this.callback = () => {\n        if (this.node) {\n          const didUpdate = applyAnimatedValues.fn(this.node, this.propsAnimated.getAnimatedValue(), this);\n          if (didUpdate === false) this.forceUpdate();\n        }\n      };\n\n      this.attachProps(props);\n    }\n\n    componentWillUnmount() {\n      this.propsAnimated && this.propsAnimated.detach();\n    }\n\n    setNativeProps(props) {\n      const didUpdate = applyAnimatedValues.fn(this.node, props, this);\n      if (didUpdate === false) this.forceUpdate();\n    } // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that\n    // changed. However, setNativeProps can only be implemented on leaf\n    // native components. If you want to animate a composite component, you\n    // need to re-render it. In this case, we have a fallback that uses\n    // forceUpdate.\n\n\n    attachProps(_ref) {\n      let forwardRef = _ref.forwardRef,\n          nextProps = _objectWithoutPropertiesLoose(_ref, [\"forwardRef\"]);\n\n      const oldPropsAnimated = this.propsAnimated;\n      this.propsAnimated = new AnimatedProps(nextProps, this.callback); // When you call detach, it removes the element from the parent list\n      // of children. If it goes to 0, then the parent also detaches itself\n      // and so on.\n      // An optimization is to attach the new elements and THEN detach the old\n      // ones instead of detaching and THEN attaching.\n      // This way the intermediate state isn't to go to 0 and trigger\n      // this expensive recursive detaching to then re-attach everything on\n      // the very next operation.\n\n      oldPropsAnimated && oldPropsAnimated.detach();\n    }\n\n    shouldComponentUpdate(props) {\n      const style = props.style,\n            nextProps = _objectWithoutPropertiesLoose(props, [\"style\"]);\n\n      const _this$props = this.props,\n            currentStyle = _this$props.style,\n            currentProps = _objectWithoutPropertiesLoose(_this$props, [\"style\"]);\n\n      if (!shallowEqual(currentProps, nextProps) || !shallowEqual(currentStyle, style)) {\n        this.attachProps(props);\n        return true;\n      }\n\n      return false;\n    }\n\n    render() {\n      const _this$propsAnimated$g = this.propsAnimated.getValue(),\n            scrollTop = _this$propsAnimated$g.scrollTop,\n            scrollLeft = _this$propsAnimated$g.scrollLeft,\n            animatedProps = _objectWithoutPropertiesLoose(_this$propsAnimated$g, [\"scrollTop\", \"scrollLeft\"]);\n\n      return React__default.createElement(Component, _extends({}, animatedProps, {\n        ref: node => this.node = handleRef(node, this.props.forwardRef)\n      }));\n    }\n\n  }\n\n  return React__default.forwardRef((props, ref) => React__default.createElement(AnimatedComponent, _extends({}, props, {\n    forwardRef: ref\n  })));\n}\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nclass Spring extends React__default.Component {\n  constructor() {\n    super(...arguments);\n    this.state = {\n      lastProps: {\n        from: {},\n        to: {}\n      },\n      propsChanged: false,\n      internal: false\n    };\n    this.controller = new Controller(null, null);\n    this.didUpdate = false;\n    this.didInject = false;\n    this.finished = true;\n\n    this.start = () => {\n      this.finished = false;\n      let wasMounted = this.mounted;\n      this.controller.start(props => this.finish(_extends({}, props, {\n        wasMounted\n      })), this.update);\n    };\n\n    this.stop = () => this.controller.stop(true);\n\n    this.update = () => this.mounted && this.setState({\n      internal: true\n    });\n\n    this.finish = (_ref) => {\n      let finished = _ref.finished,\n          noChange = _ref.noChange,\n          wasMounted = _ref.wasMounted;\n      this.finished = true;\n\n      if (this.mounted && finished) {\n        // Only call onRest if either we *were* mounted, or when there were changes\n        if (this.props.onRest && (wasMounted || !noChange)) this.props.onRest(this.controller.merged); // Restore end-state\n\n        if (this.mounted && this.didInject) {\n          this.afterInject = convertValues(this.props);\n          this.setState({\n            internal: true\n          });\n        } // If we have an inject or values to apply after the animation we ping here\n\n\n        if (this.mounted && (this.didInject || this.props.after)) this.setState({\n          internal: true\n        });\n        this.didInject = false;\n      }\n    };\n  }\n\n  componentDidMount() {\n    // componentDidUpdate isn't called on mount, we call it here to start animating\n    this.componentDidUpdate();\n    this.mounted = true;\n  }\n\n  componentWillUnmount() {\n    // Stop all ongoing animtions\n    this.mounted = false;\n    this.stop();\n  }\n\n  static getDerivedStateFromProps(props, _ref2) {\n    let internal = _ref2.internal,\n        lastProps = _ref2.lastProps;\n    // The following is a test against props that could alter the animation\n    const from = props.from,\n          to = props.to,\n          reset = props.reset,\n          force = props.force;\n    const propsChanged = !shallowEqual(to, lastProps.to) || !shallowEqual(from, lastProps.from) || reset && !internal || force && !internal;\n    return {\n      propsChanged,\n      lastProps: props,\n      internal: false\n    };\n  }\n\n  render() {\n    const children = this.props.children;\n    const propsChanged = this.state.propsChanged; // Inject phase -----------------------------------------------------------\n    // Handle injected frames, for instance targets/web/fix-auto\n    // An inject will return an intermediary React node which measures itself out\n    // .. and returns a callback when the values sought after are ready, usually \"auto\".\n\n    if (this.props.inject && propsChanged && !this.injectProps) {\n      const frame = this.props.inject(this.props, injectProps => {\n        // The inject frame has rendered, now let's update animations...\n        this.injectProps = injectProps;\n        this.setState({\n          internal: true\n        });\n      }); // Render out injected frame\n\n      if (frame) return frame;\n    } // Update phase -----------------------------------------------------------\n\n\n    if (this.injectProps || propsChanged) {\n      // We can potentially cause setState, but we're inside render, the flag prevents that\n      this.didInject = false; // Update animations, this turns from/to props into AnimatedValues\n      // An update can occur on injected props, or when own-props have changed.\n\n      if (this.injectProps) {\n        this.controller.update(this.injectProps); // didInject is needed, because there will be a 3rd stage, where the original values\n        // .. will be restored after the animation is finished. When someone animates towards\n        // .. \"auto\", the end-result should be \"auto\", not \"1999px\", which would block nested\n        // .. height/width changes.\n\n        this.didInject = true;\n      } else if (propsChanged) this.controller.update(this.props); // Flag an update that occured, componentDidUpdate will start the animation later on\n\n\n      this.didUpdate = true;\n      this.afterInject = undefined;\n      this.injectProps = undefined;\n    } // Render phase -----------------------------------------------------------\n    // Render out raw values or AnimatedValues depending on \"native\"\n\n\n    let values = _extends({}, this.controller.getValues(), this.afterInject);\n\n    if (this.finished) values = _extends({}, values, this.props.after);\n    return Object.keys(values).length ? children(values) : null;\n  }\n\n  componentDidUpdate() {\n    // The animation has to start *after* render, since at that point the scene\n    // .. graph should be established, so we do it here. Unfortunatelly, non-native\n    // .. animations as well as \"auto\"-injects call forceUpdate, so it's causing a loop.\n    // .. didUpdate prevents that as it gets set only on prop changes.\n    if (this.didUpdate) this.start();\n    this.didUpdate = false;\n  }\n\n}\nSpring.defaultProps = {\n  from: {},\n  to: {},\n  config: config.default,\n  native: false,\n  immediate: false,\n  reset: false,\n  force: false,\n  inject: bugfixes\n};\n\nclass Trail extends React__default.PureComponent {\n  constructor() {\n    super(...arguments);\n    this.first = true;\n    this.instances = new Set();\n\n    this.hook = (instance, index, length, reverse) => {\n      // Add instance to set\n      this.instances.add(instance); // Return undefined on the first index and from then on the previous instance\n\n      if (reverse ? index === length - 1 : index === 0) return undefined;else return Array.from(this.instances)[reverse ? index + 1 : index - 1];\n    };\n  }\n\n  render() {\n    const _this$props = this.props,\n          items = _this$props.items,\n          _children = _this$props.children,\n          _this$props$from = _this$props.from,\n          from = _this$props$from === void 0 ? {} : _this$props$from,\n          initial = _this$props.initial,\n          reverse = _this$props.reverse,\n          keys = _this$props.keys,\n          delay = _this$props.delay,\n          onRest = _this$props.onRest,\n          props = _objectWithoutPropertiesLoose(_this$props, [\"items\", \"children\", \"from\", \"initial\", \"reverse\", \"keys\", \"delay\", \"onRest\"]);\n\n    const array = toArray(items);\n    return toArray(array).map((item, i) => React__default.createElement(Spring, _extends({\n      onRest: i === 0 ? onRest : null,\n      key: typeof keys === 'function' ? keys(item) : toArray(keys)[i],\n      from: this.first && initial !== void 0 ? initial || {} : from\n    }, props, {\n      delay: i === 0 && delay || undefined,\n      attach: instance => this.hook(instance, i, array.length, reverse),\n      children: props => {\n        const child = _children(item, i);\n\n        return child ? child(props) : null;\n      }\n    })));\n  }\n\n  componentDidUpdate(prevProps) {\n    this.first = false;\n    if (prevProps.items !== this.props.items) this.instances.clear();\n  }\n\n}\nTrail.defaultProps = {\n  keys: item => item\n};\n\nconst DEFAULT = '__default';\n\nclass KeyframesImpl extends React__default.PureComponent {\n  constructor() {\n    var _this;\n\n    super(...arguments);\n    _this = this;\n    this.guid = 0;\n    this.state = {\n      props: {},\n      resolve: () => null,\n      last: true,\n      index: 0\n    };\n\n    this.next = function (props, last, index) {\n      if (last === void 0) {\n        last = true;\n      }\n\n      if (index === void 0) {\n        index = 0;\n      }\n\n      _this.running = true;\n      return new Promise(resolve => {\n        _this.mounted && _this.setState(state => ({\n          props,\n          resolve,\n          last,\n          index\n        }), () => _this.running = false);\n      });\n    };\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n    this.componentDidUpdate({});\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  componentDidUpdate(previous) {\n    var _this2 = this;\n\n    const _this$props = this.props,\n          states = _this$props.states,\n          f = _this$props.filter,\n          state = _this$props.state;\n\n    if (previous.state !== this.props.state || this.props.reset && !this.running || !shallowEqual(states[state], previous.states[previous.state])) {\n      if (states && state && states[state]) {\n        const localId = ++this.guid;\n        const slots = states[state];\n\n        if (slots) {\n          if (Array.isArray(slots)) {\n            let q = Promise.resolve();\n\n            for (let i = 0; i < slots.length; i++) {\n              let index = i;\n              let slot = slots[index];\n              let last = index === slots.length - 1;\n              q = q.then(() => localId === this.guid && this.next(f(slot), last, index));\n            }\n          } else if (typeof slots === 'function') {\n            let index = 0;\n            slots( // next\n            function (props, last) {\n              if (last === void 0) {\n                last = false;\n              }\n\n              return localId === _this2.guid && _this2.next(f(props), last, index++);\n            }, // cancel\n            () => requestFrame(() => this.instance && this.instance.stop()), // ownprops\n            this.props);\n          } else {\n            this.next(f(states[state]));\n          }\n        }\n      }\n    }\n  }\n\n  render() {\n    const _this$state = this.state,\n          props = _this$state.props,\n          resolve = _this$state.resolve,\n          last = _this$state.last,\n          index = _this$state.index;\n    if (!props || Object.keys(props).length === 0) return null;\n\n    let _this$props2 = this.props,\n        state = _this$props2.state,\n        filter = _this$props2.filter,\n        states = _this$props2.states,\n        config = _this$props2.config,\n        Component = _this$props2.primitive,\n        _onRest = _this$props2.onRest,\n        forwardRef = _this$props2.forwardRef,\n        rest = _objectWithoutPropertiesLoose(_this$props2, [\"state\", \"filter\", \"states\", \"config\", \"primitive\", \"onRest\", \"forwardRef\"]); // Arrayed configs need an index to process\n\n\n    if (Array.isArray(config)) config = config[index];\n    return React__default.createElement(Component, _extends({\n      ref: _ref => this.instance = handleRef(_ref, forwardRef),\n      config: config\n    }, rest, props, {\n      onRest: args => {\n        resolve(args);\n        if (_onRest && last) _onRest(args);\n      }\n    }));\n  }\n\n}\n\nKeyframesImpl.defaultProps = {\n  state: DEFAULT\n};\nconst Keyframes = React__default.forwardRef((props, ref) => React__default.createElement(KeyframesImpl, _extends({}, props, {\n  forwardRef: ref\n})));\n\nKeyframes.create = primitive => function (states, filter) {\n  if (filter === void 0) {\n    filter = states => states;\n  }\n\n  if (typeof states === 'function' || Array.isArray(states)) states = {\n    [DEFAULT]: states\n  };\n  return props => React__default.createElement(KeyframesImpl, _extends({\n    primitive: primitive,\n    states: states,\n    filter: filter\n  }, props));\n};\n\nKeyframes.Spring = states => Keyframes.create(Spring)(states, interpolateTo);\n\nKeyframes.Trail = states => Keyframes.create(Trail)(states, interpolateTo);\n\nlet guid = 0;\n\nlet get = props => {\n  let items = props.items,\n      keys = props.keys,\n      rest = _objectWithoutPropertiesLoose(props, [\"items\", \"keys\"]);\n\n  items = toArray(items !== void 0 ? items : null);\n  keys = typeof keys === 'function' ? items.map(keys) : toArray(keys); // Make sure numeric keys are interpreted as Strings (5 !== \"5\")\n\n  return _extends({\n    items,\n    keys: keys.map(key => String(key))\n  }, rest);\n};\n\nclass Transition extends React__default.PureComponent {\n  componentDidMount() {\n    this.mounted = true;\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  constructor(prevProps) {\n    super(prevProps);\n\n    this.destroyItem = (item, key, state) => values => {\n      const _this$props = this.props,\n            onRest = _this$props.onRest,\n            onDestroyed = _this$props.onDestroyed;\n\n      if (this.mounted) {\n        onDestroyed && onDestroyed(item);\n        this.setState((_ref) => {\n          let deleted = _ref.deleted;\n          return {\n            deleted: deleted.filter(t => t.key !== key)\n          };\n        });\n        onRest && onRest(item, state, values);\n      }\n    };\n\n    this.state = {\n      first: true,\n      transitions: [],\n      current: {},\n      deleted: [],\n      prevProps\n    };\n  }\n\n  static getDerivedStateFromProps(props, _ref2) {\n    let first = _ref2.first,\n        prevProps = _ref2.prevProps,\n        state = _objectWithoutPropertiesLoose(_ref2, [\"first\", \"prevProps\"]);\n\n    let _get = get(props),\n        items = _get.items,\n        keys = _get.keys,\n        initial = _get.initial,\n        from = _get.from,\n        enter = _get.enter,\n        leave = _get.leave,\n        update = _get.update,\n        _get$trail = _get.trail,\n        trail = _get$trail === void 0 ? 0 : _get$trail,\n        unique = _get.unique,\n        config = _get.config;\n\n    let _get2 = get(prevProps),\n        _keys = _get2.keys,\n        _items = _get2.items;\n\n    let current = _extends({}, state.current);\n\n    let deleted = [...state.deleted]; // Compare next keys with current keys\n\n    let currentKeys = Object.keys(current);\n    let currentSet = new Set(currentKeys);\n    let nextSet = new Set(keys);\n    let added = keys.filter(item => !currentSet.has(item));\n    let removed = state.transitions.filter(item => !item.destroyed && !nextSet.has(item.originalKey)).map(i => i.originalKey);\n    let updated = keys.filter(item => currentSet.has(item));\n    let delay = 0;\n    added.forEach(key => {\n      // In unique mode, remove fading out transitions if their key comes in again\n      if (unique && deleted.find(d => d.originalKey === key)) deleted = deleted.filter(t => t.originalKey !== key);\n      const keyIndex = keys.indexOf(key);\n      const item = items[keyIndex];\n      const state = 'enter';\n      current[key] = {\n        state,\n        originalKey: key,\n        key: unique ? String(key) : guid++,\n        item,\n        trail: delay = delay + trail,\n        config: callProp(config, item, state),\n        from: callProp(first ? initial !== void 0 ? initial || {} : from : from, item),\n        to: callProp(enter, item)\n      };\n    });\n    removed.forEach(key => {\n      const keyIndex = _keys.indexOf(key);\n\n      const item = _items[keyIndex];\n      const state = 'leave';\n      deleted.push(_extends({}, current[key], {\n        state,\n        destroyed: true,\n        left: _keys[Math.max(0, keyIndex - 1)],\n        right: _keys[Math.min(_keys.length, keyIndex + 1)],\n        trail: delay = delay + trail,\n        config: callProp(config, item, state),\n        to: callProp(leave, item)\n      }));\n      delete current[key];\n    });\n    updated.forEach(key => {\n      const keyIndex = keys.indexOf(key);\n      const item = items[keyIndex];\n      const state = 'update';\n      current[key] = _extends({}, current[key], {\n        item,\n        state,\n        trail: delay = delay + trail,\n        config: callProp(config, item, state),\n        to: callProp(update, item)\n      });\n    }); // This tries to restore order for deleted items by finding their last known siblings\n\n    let out = keys.map(key => current[key]);\n    deleted.forEach((_ref3) => {\n      let left = _ref3.left,\n          right = _ref3.right,\n          transition = _objectWithoutPropertiesLoose(_ref3, [\"left\", \"right\"]);\n\n      let pos; // Was it the element on the left, if yes, move there ...\n\n      if ((pos = out.findIndex(t => t.originalKey === left)) !== -1) pos += 1; // Or how about the element on the right ...\n\n      if (pos === -1) pos = out.findIndex(t => t.originalKey === right); // Maybe we'll find it in the list of deleted items\n\n      if (pos === -1) pos = deleted.findIndex(t => t.originalKey === left); // Checking right side as well\n\n      if (pos === -1) pos = deleted.findIndex(t => t.originalKey === right); // And if nothing else helps, move it to the start ¯\\_(ツ)_/¯\n\n      pos = Math.max(0, pos);\n      out = [...out.slice(0, pos), transition, ...out.slice(pos)];\n    });\n    return {\n      first: first && added.length === 0,\n      transitions: out,\n      current,\n      deleted,\n      prevProps: props\n    };\n  }\n\n  render() {\n    const _this$props2 = this.props,\n          initial = _this$props2.initial,\n          _this$props2$from = _this$props2.from,\n          _this$props2$enter = _this$props2.enter,\n          _this$props2$leave = _this$props2.leave,\n          _this$props2$update = _this$props2.update,\n          onDestroyed = _this$props2.onDestroyed,\n          keys = _this$props2.keys,\n          items = _this$props2.items,\n          onFrame = _this$props2.onFrame,\n          onRest = _this$props2.onRest,\n          onStart = _this$props2.onStart,\n          trail = _this$props2.trail,\n          config = _this$props2.config,\n          _children = _this$props2.children,\n          unique = _this$props2.unique,\n          reset = _this$props2.reset,\n          extra = _objectWithoutPropertiesLoose(_this$props2, [\"initial\", \"from\", \"enter\", \"leave\", \"update\", \"onDestroyed\", \"keys\", \"items\", \"onFrame\", \"onRest\", \"onStart\", \"trail\", \"config\", \"children\", \"unique\", \"reset\"]);\n\n    return this.state.transitions.map((_ref4, i) => {\n      let state = _ref4.state,\n          key = _ref4.key,\n          item = _ref4.item,\n          from = _ref4.from,\n          to = _ref4.to,\n          trail = _ref4.trail,\n          config = _ref4.config,\n          destroyed = _ref4.destroyed;\n      return React__default.createElement(Keyframes, _extends({\n        reset: reset && state === 'enter',\n        primitive: Spring,\n        state: state,\n        filter: interpolateTo,\n        states: {\n          [state]: to\n        },\n        key: key,\n        onRest: destroyed ? this.destroyItem(item, key, state) : onRest && (values => onRest(item, state, values)),\n        onStart: onStart && (() => onStart(item, state)),\n        onFrame: onFrame && (values => onFrame(item, state, values)),\n        delay: trail,\n        config: config\n      }, extra, {\n        from: from,\n        children: props => {\n          const child = _children(item, state, i);\n\n          return child ? child(props) : null;\n        }\n      }));\n    });\n  }\n\n}\nTransition.defaultProps = {\n  keys: item => item,\n  unique: false,\n  reset: false\n};\n\n// Solution: https://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly/658662\n\nconst stringShapeRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n\nfunction createInterpolation(config$$1) {\n  const outputRange = config$$1.output;\n  const outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);\n  outputRange.forEach(value => {\n    value.match(stringShapeRegex).forEach((number, i) => outputRanges[i].push(+number));\n  });\n  const interpolations = outputRange[0].match(stringShapeRegex).map((_, i) => Interpolation.create(_extends({}, config$$1, {\n    output: outputRanges[i]\n  })));\n  return input => {\n    let i = 0;\n    return outputRange[0].replace(stringShapeRegex, () => interpolations[i++](input));\n  };\n} // Render 30/fps by default\n\n\ninjectFrame(cb => setTimeout(cb, 1000 / 30), r => clearTimeout(r));\ninjectInterpolation(createInterpolation);\ninjectApplyAnimatedValues(() => false, style => style);\n\nexports.Spring = Spring;\nexports.Keyframes = Keyframes;\nexports.Transition = Transition;\nexports.Trail = Trail;\nexports.Controller = Controller;\nexports.config = config;\nexports.animated = createAnimatedComponent;\nexports.interpolate = interpolate$1;\nexports.Globals = Globals;\n"]},"metadata":{},"sourceType":"module"}