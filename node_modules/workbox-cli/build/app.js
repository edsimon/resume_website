"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
const assert = require('assert');

const ol = require('common-tags').oneLine;

const path = require('path');

const prettyBytes = require('pretty-bytes');

const watch = require('glob-watcher');

const workboxBuild = require('workbox-build');

const constants = require('./lib/constants');

const errors = require('./lib/errors');

const logger = require('./lib/logger');

const readConfig = require('./lib/read-config');

const runWizard = require('./lib/run-wizard');
/**
 * Runs the specified build command with the provided configuration.
 *
 * @param {Object} options
 */


function runBuildCommand(_x) {
  return _runBuildCommand.apply(this, arguments);
}

function _runBuildCommand() {
  _runBuildCommand = (0, _asyncToGenerator2.default)(function* ({
    command,
    config,
    watch
  }) {
    try {
      const _ref2 = yield workboxBuild[command](config),
            size = _ref2.size,
            count = _ref2.count,
            warnings = _ref2.warnings;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = warnings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          const warning = _step.value;
          logger.warn(warning);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      logger.log(`The service worker was written to ${config.swDest}\n` + `${count} files will be precached, totalling ${prettyBytes(size)}.`);

      if (watch) {
        logger.log(`\nWatching for changes...`);
      }
    } catch (error) {
      // See https://github.com/hapijs/joi/blob/v11.3.4/API.md#errors
      if (typeof error.annotate === 'function') {
        throw new Error(`${errors['config-validation-failed']}\n${error.annotate()}`);
      }

      logger.error(errors['workbox-build-runtime-error']);
      throw error;
    }
  });
  return _runBuildCommand.apply(this, arguments);
}

module.exports =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* (params = {}) {
    // This should not be a user-visible error, unless meow() messes something up.
    assert(Array.isArray(params.input), errors['missing-input']); // Default to showing the help message if there's no command provided.

    const _params$input = (0, _slicedToArray2.default)(params.input, 2),
          _params$input$ = _params$input[0],
          command = _params$input$ === void 0 ? 'help' : _params$input$,
          option = _params$input[1];

    switch (command) {
      case 'wizard':
        {
          yield runWizard(params.flags);
          break;
        }

      case 'copyLibraries':
        {
          assert(option, errors['missing-dest-dir-param']);
          const parentDirectory = path.resolve(process.cwd(), option);
          const dirName = yield workboxBuild.copyWorkboxLibraries(parentDirectory);
          const fullPath = path.join(parentDirectory, dirName);
          logger.log(`The Workbox libraries were copied to ${fullPath}`);
          logger.log(ol`Add a call to workbox.setConfig({modulePathPrefix: '...'})
        to your service worker to use these local libraries.`);
          logger.log(`See https://goo.gl/Fo9gPX for further documentation.`);
          break;
        }

      case 'generateSW':
      case 'injectManifest':
        {
          const configPath = path.resolve(process.cwd(), option || constants.defaultConfigFile);
          let config;

          try {
            config = readConfig(configPath);
          } catch (error) {
            logger.error(errors['invalid-common-js-module']);
            throw error;
          }

          logger.log(`Using configuration from ${configPath}.`); // Determine whether we're in --watch mode, or one-off mode.

          if (params.flags && params.flags.watch) {
            const options = {
              ignoreInitial: false
            };

            if (config.globIgnores) {
              options.ignored = config.globIgnores;
            }

            if (config.globDirectory) {
              options.cwd = config.globDirectory;
            }

            watch(config.globPatterns, options, () => runBuildCommand({
              command,
              config,
              watch: true
            }));
          } else {
            yield runBuildCommand({
              command,
              config,
              watch: false
            });
          }

          break;
        }

      case 'help':
        {
          params.showHelp();
          break;
        }

      default:
        {
          throw new Error(errors['unknown-command'] + ` ` + command);
        }
    }
  });

  return function () {
    return _ref.apply(this, arguments);
  };
}();