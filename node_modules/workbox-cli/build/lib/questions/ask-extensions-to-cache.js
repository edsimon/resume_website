"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
const assert = require('assert');

const glob = require('glob');

const inquirer = require('inquirer');

const ora = require('ora');

const path = require('path');

const errors = require('../errors');

const _require = require('../constants'),
      ignoredDirectories = _require.ignoredDirectories,
      ignoredFileExtensions = _require.ignoredFileExtensions; // The key used for the question/answer.


const name = 'globPatterns';
/**
 * @param {string} globDirectory The directory used for the root of globbing.
 * @return {Promise<Array<string>>} The unique file extensions corresponding
 * to all of the files under globDirectory.
 */

function getAllFileExtensions(_x) {
  return _getAllFileExtensions.apply(this, arguments);
}
/**
 * @param {string} globDirectory The directory used for the root of globbing.
 * @return {Promise<Object>} The answers from inquirer.
 */


function _getAllFileExtensions() {
  _getAllFileExtensions = (0, _asyncToGenerator2.default)(function* (globDirectory) {
    const files = yield new Promise((resolve, reject) => {
      // Use a pattern to match any file that contains a '.', since that signifies
      // the presence of a file extension.
      glob('**/*.*', {
        cwd: globDirectory,
        nodir: true,
        ignore: [...ignoredDirectories.map(directory => `**/${directory}/**`), ...ignoredFileExtensions.map(extension => `**/*.${extension}`)]
      }, (error, files) => {
        if (error) {
          reject(error);
        } else {
          resolve(files);
        }
      });
    });
    const extensions = new Set();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = files[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        const file = _step.value;
        const extension = path.extname(file);

        if (extension) {
          // Get rid of the leading . character.
          extensions.add(extension.replace(/^\./, ''));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return [...extensions];
  });
  return _getAllFileExtensions.apply(this, arguments);
}

function askQuestion(_x2) {
  return _askQuestion.apply(this, arguments);
}

function _askQuestion() {
  _askQuestion = (0, _asyncToGenerator2.default)(function* (globDirectory) {
    // We need to get a list of extensions corresponding to files in the directory
    // to use when asking the next question. That could potentially take some
    // time, so we show a spinner and explanatory text.
    const spinner = ora({
      text: `Examining files in ${globDirectory}...`,
      stream: process.stdout
    }).start();
    const fileExtensions = yield getAllFileExtensions(globDirectory);
    spinner.stop();
    assert(fileExtensions.length > 0, errors['no-file-extensions-found']);
    return inquirer.prompt([{
      name,
      message: 'Which file types would you like to precache?',
      type: 'checkbox',
      choices: fileExtensions,
      default: fileExtensions
    }]);
  });
  return _askQuestion.apply(this, arguments);
}

module.exports =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* (globDirectory) {
    const answers = yield askQuestion(globDirectory);
    const extensions = answers[name];
    assert(extensions.length > 0, errors['no-file-extensions-selected']); // glob isn't happy with a single option inside of a {} group, so use a
    // pattern without a {} group when there's only one extension.

    const extensionsPattern = extensions.length === 1 ? extensions[0] : `{${extensions.join(',')}}`;
    return [`**/*.${extensionsPattern}`];
  });

  return function (_x3) {
    return _ref.apply(this, arguments);
  };
}();